"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateRewards = calculateRewards;
function calculateRewards(stakingPool, multipliers, character, staker, till = new Date()) {
    if (character.usedBy.kind !== "Staking" ||
        !character.usedBy.params ||
        !("pool" in character.usedBy.params))
        return { rewards: 0, multipliers: 0 };
    const secondsElapsed = Math.floor(till.getTime() / 1000) - character.usedBy.params.claimedAt;
    const rewardsPerSecond = Number(stakingPool.rewardsPerDuration) /
        Number(stakingPool.rewardsDuration);
    let rewardsAmount = rewardsPerSecond * secondsElapsed;
    let totalMultipliers = 1;
    let multiplierDecimals = 1;
    if (multipliers) {
        multiplierDecimals = 10 ** multipliers.decimals;
        totalMultipliers = multiplierDecimals;
        let durationMultiplier = multiplierDecimals;
        let maxMinDuration = 0;
        for (const multiplier of multipliers.durationMultipliers) {
            if (multiplier.multiplierType.kind === "StakeDuration" &&
                "minDuration" in multiplier.multiplierType.params) {
                const minDuration = Number(multiplier.multiplierType.params.minDuration);
                if (minDuration <= secondsElapsed && minDuration > maxMinDuration) {
                    durationMultiplier = Number(multiplier.value);
                    maxMinDuration = minDuration;
                }
            }
        }
        durationMultiplier -= multiplierDecimals;
        totalMultipliers += durationMultiplier;
        let countMultiplier = multiplierDecimals;
        let maxMinCount = 0;
        for (const multiplier of multipliers.countMultipliers) {
            if (multiplier.multiplierType.kind === "NFTCount" &&
                "minCount" in multiplier.multiplierType.params) {
                const minCount = Number(multiplier.multiplierType.params.minCount);
                if (minCount <= Number(staker.totalStaked) && minCount > maxMinCount) {
                    countMultiplier = Number(multiplier.value);
                    maxMinCount = minCount;
                }
            }
        }
        countMultiplier -= multiplierDecimals;
        totalMultipliers += countMultiplier;
        if (character.source.kind === "Wrapped" &&
            "criteria" in character.source.params) {
            const criteria = character.source.params.criteria;
            let creatorMultiplier = multiplierDecimals;
            for (const multiplier of multipliers.creatorMultipliers) {
                if (multiplier.multiplierType.kind === "Creator" &&
                    "creator" in multiplier.multiplierType.params) {
                    const creator = multiplier.multiplierType.params.creator;
                    if (criteria.kind === "Creator" && criteria.params === creator) {
                        creatorMultiplier = Number(multiplier.value);
                        break;
                    }
                }
            }
            creatorMultiplier -= multiplierDecimals;
            totalMultipliers += creatorMultiplier;
            let collectionMultiplier = multiplierDecimals;
            for (const multiplier of multipliers.collectionMultipliers) {
                if (multiplier.multiplierType.kind === "Collection" &&
                    "collection" in multiplier.multiplierType.params) {
                    const collection = multiplier.multiplierType.params.collection;
                    if (criteria.kind === "Collection" &&
                        criteria.params === collection) {
                        collectionMultiplier = Number(multiplier.value);
                        break;
                    }
                }
            }
            collectionMultiplier -= multiplierDecimals;
            totalMultipliers += collectionMultiplier;
        }
    }
    rewardsAmount = (rewardsAmount * totalMultipliers) / multiplierDecimals;
    return { rewards: rewardsAmount, multipliers: totalMultipliers };
}
//# sourceMappingURL=staking.js.map