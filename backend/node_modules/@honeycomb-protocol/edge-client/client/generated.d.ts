import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { DocumentNode } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & {
    [P in K]-?: NonNullable<T[P]>;
};
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    BigInt: {
        input: string;
        output: string;
    };
    Bytes: {
        input: string;
        output: string;
    };
    JSON: {
        input: any;
        output: any;
    };
    Pubkey: {
        input: string;
        output: string;
    };
    StringTuple: {
        input: [string, string];
        output: [string, string];
    };
    VecMap: {
        input: Record<string, any>;
        output: Record<string, any>;
    };
    VecMapGeneric: {
        input: Array<[any, any]>;
        output: Array<[any, any]>;
    };
    _FieldSet: {
        input: any;
        output: any;
    };
};
export type Account = {
    __typename?: 'Account';
    address: Scalars['Bytes']['output'];
    discriminator: Scalars['Bytes']['output'];
    parsed_data?: Maybe<Scalars['JSON']['output']>;
    program_id: Scalars['Bytes']['output'];
};
export type AddMultiplierMetadataInput = {
    type?: InputMaybe<MultiplierTypeInput>;
    value: Scalars['BigInt']['input'];
};
export type AddRemoveRewardsFromRewardPoolActionInput = {
    add?: InputMaybe<Scalars['BigInt']['input']>;
    remove?: InputMaybe<Scalars['BigInt']['input']>;
};
export type AddSplMultiplierMetadataInput = {
    type?: InputMaybe<SplMultiplierInput>;
    value: Scalars['BigInt']['input'];
};
export type AdvancedTreeConfig = {
    canopyDepth: Scalars['Int']['input'];
    maxBufferSize: Scalars['Int']['input'];
    maxDepth: Scalars['Int']['input'];
};
export type Assembled = {
    __typename?: 'Assembled';
    assemblerConfig: Scalars['Pubkey']['output'];
    attributes?: Maybe<Scalars['VecMap']['output']>;
    hash?: Maybe<Scalars['Pubkey']['output']>;
    mint: Scalars['Pubkey']['output'];
    uri: Scalars['String']['output'];
};
export type AssemblerConfig = {
    __typename?: 'AssemblerConfig';
    address: Scalars['Bytes']['output'];
    discriminator: Scalars['Bytes']['output'];
    merkle_trees?: Maybe<ControlledMerkleTrees>;
    order?: Maybe<Array<Scalars['String']['output']>>;
    program_id: Scalars['Bytes']['output'];
    project: Scalars['Pubkey']['output'];
    ticker: Scalars['String']['output'];
};
export type AssemblerConfigInput = {
    assemblerConfig: Scalars['String']['input'];
    collectionName: Scalars['String']['input'];
    creators: Array<NftCreatorInput>;
    description: Scalars['String']['input'];
    name: Scalars['String']['input'];
    sellerFeeBasisPoints: Scalars['Int']['input'];
    symbol: Scalars['String']['input'];
};
export type AssetCriteria = {
    __typename?: 'AssetCriteria';
    kind: AssetCriteriaKind;
    params?: Maybe<Scalars['Pubkey']['output']>;
};
export type AssetCriteriaFilter = {
    kind?: InputMaybe<Scalars['String']['input']>;
    params?: InputMaybe<Scalars['Pubkey']['input']>;
};
export type AssetCriteriaInput = {
    kind: Scalars['String']['input'];
    params: Scalars['Bytes']['input'];
};
export declare enum AssetCriteriaKind {
    Collection = "Collection",
    Creator = "Creator",
    MerkleTree = "MerkleTree",
    Prepopulated = "Prepopulated"
}
export type AssociatedProgram = {
    __typename?: 'AssociatedProgram';
    address: Scalars['Pubkey']['output'];
    trustedActions: Array<SerializableActions>;
};
export type AssociatedProgramInput = {
    address: Scalars['String']['input'];
    trustedActions: Array<SerializableActionsInput>;
};
export type AuthConfirmed = {
    __typename?: 'AuthConfirmed';
    accessToken: Scalars['String']['output'];
    user: User;
};
export type AuthResponse = {
    __typename?: 'AuthResponse';
    message: Scalars['String']['output'];
    tx?: Maybe<Scalars['Bytes']['output']>;
};
export type BadgeCriteria = {
    __typename?: 'BadgeCriteria';
    condition: BadgesCondition;
    endTime: Scalars['BigInt']['output'];
    index: Scalars['Int']['output'];
    startTime: Scalars['BigInt']['output'];
};
export declare enum BadgesCondition {
    Public = "Public"
}
export type BasicTreeConfig = {
    numAssets: Scalars['Int']['input'];
};
export declare enum BuzzGuildPermissionInput {
    ManageGuildKit = "ManageGuildKit"
}
export type Character = {
    __typename?: 'Character';
    address: Scalars['Bytes']['output'];
    asset?: Maybe<Scalars['JSON']['output']>;
    cooldown: CharacterCooldown;
    equipments: Scalars['VecMap']['output'];
    leaf_idx: Scalars['BigInt']['output'];
    owner: Scalars['Pubkey']['output'];
    proof?: Maybe<Proof>;
    source: CharacterSource;
    tree_id: Scalars['Bytes']['output'];
    usedBy: CharacterUsedBy;
};
export type CharacterConfig = CharacterConfigAssembled | CharacterConfigWrapped;
export type CharacterConfigAssembled = {
    __typename?: 'CharacterConfigAssembled';
    assemblerConfig: Scalars['Pubkey']['output'];
    collectionName: Scalars['String']['output'];
    creators: Array<NftCreator>;
    description: Scalars['String']['output'];
    kind: Scalars['String']['output'];
    mintAs: MintAs;
    name: Scalars['String']['output'];
    sellerFeeBasisPoints: Scalars['Int']['output'];
    symbol: Scalars['String']['output'];
};
export type CharacterConfigInput = {
    assemblerConfigInput?: InputMaybe<AssemblerConfigInput>;
    criterias?: InputMaybe<Array<AssetCriteriaInput>>;
    kind: Scalars['String']['input'];
};
export type CharacterConfigWrapped = {
    __typename?: 'CharacterConfigWrapped';
    criterias: Array<AssetCriteria>;
    kind: Scalars['String']['output'];
};
export type CharacterCooldown = {
    __typename?: 'CharacterCooldown';
    ejection: Scalars['Int']['output'];
};
export type CharacterCooldownInput = {
    ejection: Scalars['Int']['input'];
};
export type CharacterHistory = {
    __typename?: 'CharacterHistory';
    address: Scalars['Bytes']['output'];
    event: Scalars['String']['output'];
    event_data: Scalars['JSON']['output'];
    time: Scalars['String']['output'];
};
export declare enum CharacterManagerPermissionInput {
    AssignCharacterTraits = "AssignCharacterTraits",
    ManageAssemblerConfig = "ManageAssemblerConfig",
    ManageCharacterModels = "ManageCharacterModels"
}
export type CharacterModel = {
    __typename?: 'CharacterModel';
    address: Scalars['Bytes']['output'];
    attributes: Scalars['VecMapGeneric']['output'];
    bump: Scalars['Int']['output'];
    config: CharacterConfig;
    cooldown: CharacterCooldown;
    discriminator: Scalars['Bytes']['output'];
    equipableCriteria: Array<Scalars['String']['output']>;
    key: Scalars['Pubkey']['output'];
    merkle_trees: ControlledMerkleTrees;
    program_id: Scalars['Bytes']['output'];
    project: Scalars['Pubkey']['output'];
};
export type CharacterSource = {
    __typename?: 'CharacterSource';
    kind: CharacterSourceKind;
    params: CharacterSourceParams;
};
export type CharacterSourceFilter = {
    kind?: InputMaybe<Scalars['String']['input']>;
    params?: InputMaybe<CharacterSourceParamsFilter>;
};
export declare enum CharacterSourceKind {
    Assembled = "Assembled",
    Wrapped = "Wrapped"
}
export type CharacterSourceParams = Assembled | Wrapped;
export type CharacterSourceParamsFilter = {
    criteria?: InputMaybe<AssetCriteriaFilter>;
    is_compressed?: InputMaybe<Scalars['Boolean']['input']>;
    mint?: InputMaybe<Scalars['Pubkey']['input']>;
};
export type CharacterTrait = {
    __typename?: 'CharacterTrait';
    address: Scalars['Bytes']['output'];
    layer: Scalars['String']['output'];
    leaf_idx: Scalars['BigInt']['output'];
    name: Scalars['String']['output'];
    proof?: Maybe<Proof>;
    tree_id: Scalars['Bytes']['output'];
    uri: Scalars['String']['output'];
};
export type CharacterTraitInput = {
    layer: Scalars['String']['input'];
    name: Scalars['String']['input'];
    uri: Scalars['String']['input'];
};
export type CharacterUsedBy = {
    __typename?: 'CharacterUsedBy';
    kind: Scalars['String']['output'];
    params?: Maybe<CharacterUsedByParams>;
};
export type CharacterUsedByFilter = {
    kind?: InputMaybe<Scalars['String']['input']>;
    params?: InputMaybe<CharacterUsedByParamsFilter>;
};
export type CharacterUsedByParams = UsedByCustom | UsedByEjected | UsedByGuild | UsedByMission | UsedByStaking;
export type CharacterUsedByParamsFilter = {
    claimedAt?: InputMaybe<Scalars['Int']['input']>;
    endTime?: InputMaybe<Scalars['Int']['input']>;
    id?: InputMaybe<Scalars['Pubkey']['input']>;
    mint?: InputMaybe<Scalars['Pubkey']['input']>;
    order?: InputMaybe<Scalars['Int']['input']>;
    pool?: InputMaybe<Scalars['Pubkey']['input']>;
    rewards?: InputMaybe<Array<EarnedRewardsFilter>>;
    rewardsCollected?: InputMaybe<Scalars['Boolean']['input']>;
    role?: InputMaybe<GuildRoleFilter>;
    stakedAt?: InputMaybe<Scalars['Int']['input']>;
    staker?: InputMaybe<Scalars['Pubkey']['input']>;
    user?: InputMaybe<Scalars['Pubkey']['input']>;
};
export type CharactersFilter = {
    owner?: InputMaybe<Scalars['Pubkey']['input']>;
    source?: InputMaybe<CharacterSourceFilter>;
    usedBy?: InputMaybe<CharacterUsedByFilter>;
};
export declare enum CivicGateway {
    IdVerificationPass = "IdVerificationPass",
    LivenessPass = "LivenessPass",
    UniquenessPass = "UniquenessPass"
}
export type CivicInfo = {
    __typename?: 'CivicInfo';
    expiry?: Maybe<Scalars['String']['output']>;
    gatekeeperNetwork: CivicGateway;
    walletIndex: Scalars['Int']['output'];
};
export type CivicInfoInput = {
    gatekeeperNetwork: CivicGateway;
    wallet: Scalars['String']['input'];
};
export type ClaimBadgeCriteriaInput = {
    criteriaIndex: Scalars['Int']['input'];
    payer: Scalars['Pubkey']['input'];
    profileAddress: Scalars['Pubkey']['input'];
    projectAddress: Scalars['Pubkey']['input'];
    proof: BadgesCondition;
};
export type CompressedAccount = {
    __typename?: 'CompressedAccount';
    leaf_idx?: Maybe<Scalars['BigInt']['output']>;
    parsed_data?: Maybe<Scalars['JSON']['output']>;
    raw_data?: Maybe<Scalars['Bytes']['output']>;
    schema_validated?: Maybe<Scalars['Boolean']['output']>;
    tree_id?: Maybe<Scalars['Bytes']['output']>;
};
export type ControlledMerkleTrees = {
    __typename?: 'ControlledMerkleTrees';
    active: Scalars['Int']['output'];
    merkle_trees: Array<Scalars['Pubkey']['output']>;
    schema: Scalars['JSON']['output'];
};
export type CreateAssemblerConfigTransactionResponse = {
    __typename?: 'CreateAssemblerConfigTransactionResponse';
    assemblerConfig: Scalars['Bytes']['output'];
    cost?: Maybe<Scalars['Float']['output']>;
    maxTreeCapacity?: Maybe<Scalars['Int']['output']>;
    proofBytes?: Maybe<Scalars['Int']['output']>;
    space?: Maybe<Scalars['Int']['output']>;
    treeAddress?: Maybe<Scalars['Bytes']['output']>;
    tx: Transaction;
};
export type CreateBadgeCriteriaInput = {
    authority: Scalars['Pubkey']['input'];
    badgeIndex: Scalars['Int']['input'];
    condition: BadgesCondition;
    endTime?: InputMaybe<Scalars['Int']['input']>;
    payer?: InputMaybe<Scalars['Pubkey']['input']>;
    projectAddress: Scalars['Pubkey']['input'];
    startTime?: InputMaybe<Scalars['Int']['input']>;
};
export type CreateBeginCookingTransactionResponse = {
    __typename?: 'CreateBeginCookingTransactionResponse';
    cooking: Scalars['Bytes']['output'];
    transaction: Transaction;
};
export type CreateCharacterModelTransactionResponse = {
    __typename?: 'CreateCharacterModelTransactionResponse';
    characterModel: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateCreateHolderAccountTransactionResponse = {
    __typename?: 'CreateCreateHolderAccountTransactionResponse';
    holderAccount: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateCreateMissionPoolTransactionResponse = {
    __typename?: 'CreateCreateMissionPoolTransactionResponse';
    missionPoolAddress: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateCreateMissionTransactionResponse = {
    __typename?: 'CreateCreateMissionTransactionResponse';
    missionAddress: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateCreateNewResourceTreeTransactionResponse = {
    __typename?: 'CreateCreateNewResourceTreeTransactionResponse';
    tree: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateCreateProjectTransactionResponse = {
    __typename?: 'CreateCreateProjectTransactionResponse';
    project: Scalars['String']['output'];
    tx: Transaction;
};
export type CreateCreateSplStakingPoolTransactionResponse = {
    __typename?: 'CreateCreateSplStakingPoolTransactionResponse';
    splStakingPoolAddress: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateCreateStakingPoolTransactionResponse = {
    __typename?: 'CreateCreateStakingPoolTransactionResponse';
    multipliersAddress?: Maybe<Scalars['Bytes']['output']>;
    stakingPoolAddress: Scalars['Bytes']['output'];
    transactions: Transactions;
};
export type CreateInitMultipliersTransactionResponse = {
    __typename?: 'CreateInitMultipliersTransactionResponse';
    multipliersAddress: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateInitResourceTransactionResponse = {
    __typename?: 'CreateInitResourceTransactionResponse';
    resource: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateInitializeFaucetTransactionResponse = {
    __typename?: 'CreateInitializeFaucetTransactionResponse';
    faucet: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type CreateInitializeRecipeTransactionResponse = {
    __typename?: 'CreateInitializeRecipeTransactionResponse';
    recipe: Scalars['Bytes']['output'];
    transactions: Transactions;
};
export type CreateSplRewardPoolArgsInput = {
    ApyConfig?: InputMaybe<RewardPoolConfigApyInput>;
};
export type CreateSplStakingPoolMetadataInput = {
    endTime?: InputMaybe<Scalars['BigInt']['input']>;
    maxStakeDurationSecs?: InputMaybe<Scalars['BigInt']['input']>;
    minStakeDurationSecs?: InputMaybe<Scalars['BigInt']['input']>;
    name: Scalars['String']['input'];
    startTime?: InputMaybe<Scalars['BigInt']['input']>;
};
export type CreateStakingPoolMetadataInput = {
    cooldownDuration?: InputMaybe<Scalars['BigInt']['input']>;
    endTime?: InputMaybe<Scalars['BigInt']['input']>;
    lockType?: InputMaybe<LockTypeEnum>;
    maxRewardsDuration?: InputMaybe<Scalars['BigInt']['input']>;
    minStakeDuration?: InputMaybe<Scalars['BigInt']['input']>;
    name: Scalars['String']['input'];
    resetStakeDuration: Scalars['Boolean']['input'];
    rewardsDuration: Scalars['BigInt']['input'];
    rewardsPerDuration: Scalars['BigInt']['input'];
    startTime: Scalars['BigInt']['input'];
};
export type CreateUpdateMissionPoolTransactionResponse = {
    __typename?: 'CreateUpdateMissionPoolTransactionResponse';
    tx: Transaction;
};
export type CreateUpdateMissionTransactionResponse = {
    __typename?: 'CreateUpdateMissionTransactionResponse';
    tx: Transaction;
};
export type CustomDataInput = {
    add?: InputMaybe<Scalars['JSON']['input']>;
    remove?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type DelegateAuthority = {
    __typename?: 'DelegateAuthority';
    address: Scalars['Bytes']['output'];
    authority: Scalars['Pubkey']['output'];
    bump: Scalars['Int']['output'];
    delegations: Array<ServiceDelegation>;
    project: Scalars['Pubkey']['output'];
};
export type DisrcriminatorFilter = {
    accountName: Scalars['String']['input'];
    programId: Scalars['String']['input'];
};
export type EarnedRewards = {
    __typename?: 'EarnedRewards';
    collected: Scalars['Boolean']['output'];
    delta: Scalars['Int']['output'];
    rewardIdx: Scalars['Int']['output'];
};
export type EarnedRewardsFilter = {
    delta?: InputMaybe<Scalars['Int']['input']>;
    rewardIdx?: InputMaybe<Scalars['Int']['input']>;
};
export type Faucet = {
    __typename?: 'Faucet';
    address: Scalars['Bytes']['output'];
    amount: Scalars['BigInt']['output'];
    lastClaimed: Scalars['BigInt']['output'];
    project: Scalars['Pubkey']['output'];
    repeatInterval: Scalars['BigInt']['output'];
    resource: Scalars['Pubkey']['output'];
};
export type Global = {
    __typename?: 'Global';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    config: Scalars['VecMap']['output'];
    totalUsers: Scalars['Int']['output'];
    userTrees: ControlledMerkleTrees;
};
export type GuildRole = {
    __typename?: 'GuildRole';
    kind: Scalars['String']['output'];
};
export type GuildRoleFilter = {
    kind?: InputMaybe<Scalars['String']['input']>;
};
export declare enum HiveControlPermissionInput {
    ManageCriterias = "ManageCriterias",
    ManageProjectDriver = "ManageProjectDriver",
    ManageServices = "ManageServices",
    UpdatePlatformData = "UpdatePlatformData"
}
export type Holding = {
    __typename?: 'Holding';
    address: Scalars['Bytes']['output'];
    balance: Scalars['BigInt']['output'];
    characteristics?: Maybe<Scalars['VecMap']['output']>;
    holder: Scalars['Pubkey']['output'];
    leaf_idx: Scalars['BigInt']['output'];
    proof?: Maybe<Proof>;
    tree_id: Scalars['Bytes']['output'];
};
export type ImportResourceInput = {
    authority: Scalars['String']['input'];
    custody?: InputMaybe<ImportResourceInputCustodyInput>;
    decimals: Scalars['Int']['input'];
    mint: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    storage: ResourceStorageEnum;
    tags?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type ImportResourceInputCustodyInput = {
    burnerDestination?: InputMaybe<Scalars['String']['input']>;
    supply: Scalars['BigInt']['input'];
};
export type Ingredient = {
    __typename?: 'Ingredient';
    amount: Scalars['BigInt']['output'];
    resourceAddress: Scalars['Pubkey']['output'];
};
export type IngredientsInput = {
    amount: Scalars['BigInt']['input'];
    resourceAddress: Scalars['String']['input'];
};
export type InitResourceInput = {
    decimals: Scalars['Int']['input'];
    name: Scalars['String']['input'];
    storage: ResourceStorageEnum;
    symbol: Scalars['String']['input'];
    tags?: InputMaybe<Array<Scalars['String']['input']>>;
    uri: Scalars['String']['input'];
};
export type InitStakingMultiplierMetadataInput = {
    decimals: Scalars['Int']['input'];
    multipliers: Array<InputMaybe<AddMultiplierMetadataInput>>;
};
export type LockType = {
    __typename?: 'LockType';
    kind?: Maybe<Scalars['String']['output']>;
};
export declare enum LockTypeEnum {
    Custody = "Custody",
    Freeze = "Freeze"
}
export type Meal = {
    __typename?: 'Meal';
    amount: Scalars['BigInt']['output'];
    resourceAddress: Scalars['Pubkey']['output'];
};
export type MealInput = {
    amount: Scalars['BigInt']['input'];
    resourceAddress: Scalars['String']['input'];
};
export type MintAs = {
    __typename?: 'MintAs';
    kind: MintAsKind;
    params?: Maybe<MintAsParams>;
};
export type MintAsInput = {
    kind?: InputMaybe<MintAsKind>;
    mplBubblegum?: InputMaybe<MintAsMplBubblegumInput>;
};
export declare enum MintAsKind {
    MplBubblegum = "MplBubblegum",
    MplCore = "MplCore",
    MplMetadata = "MplMetadata",
    TokenExtensions = "TokenExtensions"
}
export type MintAsMplBubblegumInput = {
    maxBufferSize: Scalars['Int']['input'];
    maxDepth: Scalars['Int']['input'];
};
export type MintAsParams = MintAsParamsMplBubblegum;
export type MintAsParamsMplBubblegum = {
    __typename?: 'MintAsParamsMplBubblegum';
    merkleTree: Scalars['Pubkey']['output'];
};
export type Mission = {
    __typename?: 'Mission';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    cost: MissionCost;
    discriminator: Scalars['Bytes']['output'];
    minXp: Scalars['BigInt']['output'];
    missionPool: Scalars['Pubkey']['output'];
    name: Scalars['String']['output'];
    program_id: Scalars['Bytes']['output'];
    project: Scalars['Pubkey']['output'];
    requirement: MissionRequirement;
    rewards: Array<Maybe<Reward>>;
};
export type MissionCost = {
    __typename?: 'MissionCost';
    amount: Scalars['BigInt']['output'];
    resource_address: Scalars['Pubkey']['output'];
};
export type MissionPool = {
    __typename?: 'MissionPool';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    characterModels: Array<Maybe<Scalars['Pubkey']['output']>>;
    discriminator: Scalars['Bytes']['output'];
    factionsMerkleRoot: Scalars['Bytes']['output'];
    guildKits: Array<Maybe<Scalars['Int']['output']>>;
    name: Scalars['String']['output'];
    program_id: Scalars['Bytes']['output'];
    project: Scalars['Pubkey']['output'];
    randomizerRound: Scalars['Int']['output'];
};
export type MissionRequirement = TimeRequirement;
export type MissionReward = {
    kind: RewardKind;
    max: Scalars['BigInt']['input'];
    min: Scalars['BigInt']['input'];
    resource?: InputMaybe<Scalars['String']['input']>;
};
export type ModifyDelegationInput = {
    delegation?: InputMaybe<ModifyServiceDelegationInput>;
    index?: InputMaybe<Scalars['Int']['input']>;
};
export type ModifyServiceDelegationInput = {
    BuzzGuild?: InputMaybe<ServiceDelegationBuzzGuild>;
    CharacterManager?: InputMaybe<ServiceDelegationCharacterManager>;
    HiveControl?: InputMaybe<ServiceDelegationHiveControl>;
    NectarMissions?: InputMaybe<ServiceDelegationNectarMissions>;
    NectarStaking?: InputMaybe<ServiceDelegationNectarStaking>;
    ResourceManager?: InputMaybe<ServiceDelegationResourceManager>;
};
export type Multiplier = {
    __typename?: 'Multiplier';
    multiplierType: MultiplierType;
    value: Scalars['BigInt']['output'];
};
export type MultiplierType = {
    __typename?: 'MultiplierType';
    kind: Scalars['String']['output'];
    params: MultiplierTypeParams;
};
export type MultiplierTypeInput = {
    collection?: InputMaybe<Scalars['String']['input']>;
    creator?: InputMaybe<Scalars['String']['input']>;
    minNftCount?: InputMaybe<Scalars['BigInt']['input']>;
    minStakeDuration?: InputMaybe<Scalars['BigInt']['input']>;
};
export type MultiplierTypeParams = MultiplierTypeParamsCollection | MultiplierTypeParamsCreator | MultiplierTypeParamsNftCount | MultiplierTypeParamsStakeDuration;
export type MultiplierTypeParamsCollection = {
    __typename?: 'MultiplierTypeParamsCollection';
    collection: Scalars['Pubkey']['output'];
};
export type MultiplierTypeParamsCreator = {
    __typename?: 'MultiplierTypeParamsCreator';
    creator: Scalars['Pubkey']['output'];
};
export type MultiplierTypeParamsNftCount = {
    __typename?: 'MultiplierTypeParamsNFTCount';
    minCount: Scalars['BigInt']['output'];
};
export type MultiplierTypeParamsStakeDuration = {
    __typename?: 'MultiplierTypeParamsStakeDuration';
    minDuration: Scalars['BigInt']['output'];
};
export type Multipliers = {
    __typename?: 'Multipliers';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    collectionMultipliers: Array<Multiplier>;
    countMultipliers: Array<Multiplier>;
    creatorMultipliers: Array<Multiplier>;
    decimals: Scalars['Int']['output'];
    durationMultipliers: Array<Multiplier>;
    stakingPool: Scalars['Pubkey']['output'];
};
export declare enum NectarMissionsPermissionInput {
    ManageMissionPool = "ManageMissionPool",
    WithdrawMissionPoolRewards = "WithdrawMissionPoolRewards"
}
export declare enum NectarStakingPermissionInput {
    ManageStakingPool = "ManageStakingPool",
    WithdrawStakingPoolRewards = "WithdrawStakingPoolRewards"
}
export type NewMissionCost = {
    address: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
};
export type NewMissionData = {
    authority: Scalars['String']['input'];
    cost: NewMissionCost;
    duration: Scalars['BigInt']['input'];
    minXp: Scalars['BigInt']['input'];
    missionPool: Scalars['String']['input'];
    name: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
    rewards: Array<InputMaybe<MissionReward>>;
};
export type NewMissionPoolData = {
    authority: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    name: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
};
export type NftCreator = {
    __typename?: 'NftCreator';
    address: Scalars['Pubkey']['output'];
    share: Scalars['Int']['output'];
};
export type NftCreatorInput = {
    address: Scalars['String']['input'];
    share: Scalars['Int']['input'];
};
export type Node = {
    __typename?: 'Node';
    hash: Scalars['Bytes']['output'];
    id: Scalars['ID']['output'];
    leaf_idx?: Maybe<Scalars['BigInt']['output']>;
    level: Scalars['BigInt']['output'];
    node_idx: Scalars['BigInt']['output'];
    seq: Scalars['BigInt']['output'];
    tree: Scalars['Bytes']['output'];
};
export type OutputHolding = Holding | OutputHoldingTree;
export type OutputHoldingTree = {
    __typename?: 'OutputHoldingTree';
    tree: Scalars['Bytes']['output'];
};
export type PartialUserInfoInput = {
    bio?: InputMaybe<Scalars['String']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    pfp?: InputMaybe<Scalars['String']['input']>;
};
export type ParticipateOnMissionData = {
    authority: Scalars['String']['input'];
    characterAddresses: Array<Scalars['String']['input']>;
    mission: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    userId?: InputMaybe<Scalars['Int']['input']>;
};
export type PlatformData = {
    __typename?: 'PlatformData';
    achievements: Array<Scalars['Int']['output']>;
    custom: Scalars['VecMap']['output'];
    xp: Scalars['BigInt']['output'];
};
export type PlatformDataInput = {
    addAchievements?: InputMaybe<Array<Scalars['Int']['input']>>;
    addXp?: InputMaybe<Scalars['BigInt']['input']>;
    custom?: InputMaybe<CustomDataInput>;
};
export type Profile = {
    __typename?: 'Profile';
    address: Scalars['Bytes']['output'];
    customData: Scalars['VecMap']['output'];
    identity: Scalars['String']['output'];
    info: ProfileInfo;
    leaf_idx: Scalars['BigInt']['output'];
    platformData: PlatformData;
    project: Scalars['Pubkey']['output'];
    proof?: Maybe<Proof>;
    tree_id: Scalars['Bytes']['output'];
    user?: Maybe<User>;
    userId: Scalars['Int']['output'];
};
export type ProfileDataConfig = {
    __typename?: 'ProfileDataConfig';
    achievements: Array<Scalars['String']['output']>;
    customDataFields: Array<Scalars['String']['output']>;
};
export type ProfileDataConfigInput = {
    achievements: Array<Scalars['String']['input']>;
    customDataFields: Array<Scalars['String']['input']>;
};
export type ProfileInfo = {
    __typename?: 'ProfileInfo';
    bio?: Maybe<Scalars['String']['output']>;
    name?: Maybe<Scalars['String']['output']>;
    pfp?: Maybe<Scalars['String']['output']>;
};
export type ProfileInfoInput = {
    bio?: InputMaybe<Scalars['String']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    pfp?: InputMaybe<Scalars['String']['input']>;
};
export type Project = {
    __typename?: 'Project';
    address: Scalars['Bytes']['output'];
    associatedPrograms: Array<AssociatedProgram>;
    authority: Scalars['Pubkey']['output'];
    badgeCriteria?: Maybe<Array<BadgeCriteria>>;
    bump: Scalars['Int']['output'];
    driver: Scalars['Pubkey']['output'];
    key: Scalars['Pubkey']['output'];
    name: Scalars['String']['output'];
    profileDataConfig: ProfileDataConfig;
    profileTrees: ControlledMerkleTrees;
    services: Array<Service>;
    subsidyFees: Scalars['Boolean']['output'];
};
export type Proof = {
    __typename?: 'Proof';
    canopy_depth: Scalars['Int']['output'];
    leaf: Scalars['Bytes']['output'];
    leaf_index: Scalars['BigInt']['output'];
    maxDepth: Scalars['Int']['output'];
    node_index: Scalars['BigInt']['output'];
    proof: Array<Scalars['Bytes']['output']>;
    root: Scalars['Bytes']['output'];
    tree_id: Scalars['Bytes']['output'];
};
export type Query = {
    __typename?: 'Query';
    account: Array<Account>;
    assemblerConfig: Array<AssemblerConfig>;
    authConfirm: AuthConfirmed;
    authRequest: AuthResponse;
    character: Array<Character>;
    characterHistory: Array<CharacterHistory>;
    characterModel: Array<CharacterModel>;
    characterTrait: Array<CharacterTrait>;
    compressedAccount: Array<CompressedAccount>;
    createAddCharacterTraitsTransactions: Transactions;
    createAddIngredientsTransaction: Transactions;
    createAddMultiplierTransaction: Transaction;
    createAddRemoveRewardsFromRewardPoolTransaction: Transaction;
    createAddRemoveSplMultipliersTransaction: Transaction;
    createAssembleCharacterTransaction: Transaction;
    createBurnAssetsTransactions: Transactions;
    createBurnResourceTransaction: Transaction;
    createChangeProjectDriverTransaction: Transaction;
    createClaimBadgeCriteriaTransaction: Transaction;
    createClaimFaucetTransaction: Transaction;
    createClaimSplRewardsTransaction: Transaction;
    createClaimStakingRewardsTransactions: Transactions;
    createCreateAssemblerConfigTransaction: CreateAssemblerConfigTransactionResponse;
    createCreateCharacterModelTransaction: CreateCharacterModelTransactionResponse;
    createCreateCharactersTreeTransaction: TreeSetupResponse;
    createCreateDelegateAuthorityTransaction: Transaction;
    createCreateMissionPoolTransaction: CreateCreateMissionPoolTransactionResponse;
    createCreateMissionTransaction: CreateCreateMissionTransactionResponse;
    createCreateNewResourceTransaction: CreateInitResourceTransactionResponse;
    createCreateNewResourceTreeTransaction: TreeSetupResponse;
    createCreateNewSplStakingPoolTreeTransaction: TreeSetupResponse;
    createCreateProfilesTreeTransaction: TreeSetupResponse;
    createCreateProjectTransaction: CreateCreateProjectTransactionResponse;
    createCreateSplStakingPoolTransaction: CreateCreateSplStakingPoolTransactionResponse;
    createCreateStakingPoolTransaction: CreateCreateStakingPoolTransactionResponse;
    createCreateUnwrapHoldingTransaction: Transaction;
    createCreateWrapHoldingTransaction: Transaction;
    createDismountResourceOnCharacterTransaction: Transaction;
    createEquipResourceOnCharacterTransaction: Transaction;
    createExportFungibleResourceTransaction: Transaction;
    createImportFungibleResourceTransaction: CreateInitResourceTransactionResponse;
    createInitCookingProcessTransactions: Transactions;
    createInitMultipliersTransaction: CreateInitMultipliersTransactionResponse;
    createInitializeBadgeCriteriaTransaction: Transaction;
    createInitializeFaucetTransaction: CreateInitializeFaucetTransactionResponse;
    createInitializeRecipeTransaction: CreateInitializeRecipeTransactionResponse;
    createMintResourceTransaction: Transaction;
    createModifyDelegationTransaction: Transaction;
    createNewProfileTransaction: Transaction;
    createNewUserBulkTransaction: Transactions;
    createNewUserTransaction: Transaction;
    createNewUserWithProfileTransaction: Transaction;
    createPopulateCharacterTransaction: Transaction;
    createRecallCharactersTransaction: Transactions;
    createRemoveCharacterTraitsTransactions: Transactions;
    createRemoveIngredientsTransaction: Transactions;
    createSendCharactersOnMissionTransaction: Transactions;
    createSplRewardPoolTransaction: Transaction;
    createStakeCharactersTransactions: Transactions;
    createStakeSplTokensTransaction: Transaction;
    createTransferAssetsTransactions: Transactions;
    createTransferResourceTransaction: Transaction;
    createUnstakeCharactersTransactions: Transactions;
    createUnstakeSplTokensTransaction: Transaction;
    createUnwrapAssetsFromCharacterTransactions: Transactions;
    createUpdateBadgeCriteriaTransaction: Transaction;
    createUpdateCharacterTraitsTransaction: Transaction;
    createUpdateMissionPoolTransaction: CreateUpdateMissionPoolTransactionResponse;
    createUpdateMissionTransaction: Transaction;
    createUpdatePlatformDataTransaction: Transaction;
    createUpdateProfileTransaction: Transaction;
    createUpdateSplStakingPoolTransaction: Transaction;
    createUpdateStakingPoolTransaction: Transaction;
    createUpdateUserTransaction: Transaction;
    createUseCharacterTransaction: Transaction;
    createWrapAssetsToCharacterTransactions: Transactions;
    delegateAuthority: Array<DelegateAuthority>;
    faucets: Array<Faucet>;
    global: Global;
    holdings: Array<Holding>;
    mission: Array<Mission>;
    missionPool: Array<MissionPool>;
    multipliers: Array<Multipliers>;
    profile: Array<Profile>;
    project: Array<Project>;
    proof: Array<Proof>;
    recipes: Array<Recipe>;
    resources: Array<Resource>;
    resourcesBalance: Array<ResourceBalance>;
    sendBulkTransactions: Array<TransactionResponse>;
    sendTransactionBundles: Array<TransactionBundleResponse>;
    signWithShadowSignerAndSendBulkTransactions: Array<TransactionResponse>;
    signWithShadowSignerAndSendTransactionBundles: Array<TransactionBundleResponse>;
    splStakingPools: Array<SplStakingPool>;
    splStakingRecipients: Array<StakingRecipient>;
    stakers: Array<Staker>;
    stakingPools: Array<StakingPool>;
    user: Array<User>;
};
export type QueryAccountArgs = {
    discriminator?: InputMaybe<Scalars['Bytes']['input']>;
    parsedData?: InputMaybe<Scalars['JSON']['input']>;
    programId: Scalars['Bytes']['input'];
};
export type QueryAssemblerConfigArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    characterModel?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    project?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    tickers?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryAuthConfirmArgs = {
    signature: Scalars['String']['input'];
    wallet: Scalars['String']['input'];
};
export type QueryAuthRequestArgs = {
    useRpc?: InputMaybe<Scalars['String']['input']>;
    useTx?: InputMaybe<Scalars['Boolean']['input']>;
    wallet: Scalars['String']['input'];
};
export type QueryCharacterArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    attributeHashes?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    filters?: InputMaybe<CharactersFilter>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    mints?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    wallets?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryCharacterHistoryArgs = {
    addresses: Array<Scalars['Bytes']['input']>;
    event?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCharacterModelArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    assemblerConfigs?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    project?: InputMaybe<Scalars['Pubkey']['input']>;
};
export type QueryCharacterTraitArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']>>;
};
export type QueryCompressedAccountArgs = {
    addresses: Array<Scalars['Bytes']['input']>;
    identity?: InputMaybe<DisrcriminatorFilter>;
    leaves?: InputMaybe<Array<TreeLeaf>>;
    parsedData?: InputMaybe<Scalars['JSON']['input']>;
};
export type QueryCreateAddCharacterTraitsTransactionsArgs = {
    assemblerConfig: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    traits: Array<CharacterTraitInput>;
};
export type QueryCreateAddIngredientsTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    ingredients: Array<IngredientsInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    recipe: Scalars['String']['input'];
};
export type QueryCreateAddMultiplierTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    metadata: AddMultiplierMetadataInput;
    multiplier: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
};
export type QueryCreateAddRemoveRewardsFromRewardPoolTransactionArgs = {
    action: AddRemoveRewardsFromRewardPoolActionInput;
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    rewardTokenMint: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
};
export type QueryCreateAddRemoveSplMultipliersTransactionArgs = {
    add?: InputMaybe<Array<AddSplMultiplierMetadataInput>>;
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    remove?: InputMaybe<Array<Scalars['Int']['input']>>;
    splStakingPool: Scalars['String']['input'];
};
export type QueryCreateAssembleCharacterTransactionArgs = {
    assemblerConfig: Scalars['String']['input'];
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    authority: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    uri?: InputMaybe<Scalars['String']['input']>;
};
export type QueryCreateBurnAssetsTransactionsArgs = {
    addresses: Array<Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateBurnResourceTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner?: InputMaybe<Scalars['String']['input']>;
    payer?: InputMaybe<Scalars['String']['input']>;
    resource: Scalars['String']['input'];
};
export type QueryCreateChangeProjectDriverTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    driver: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
};
export type QueryCreateClaimBadgeCriteriaTransactionArgs = {
    args: ClaimBadgeCriteriaInput;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateClaimFaucetTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    faucet: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
};
export type QueryCreateClaimSplRewardsTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    staker: Scalars['String']['input'];
    stakingReciept: Scalars['String']['input'];
};
export type QueryCreateClaimStakingRewardsTransactionsArgs = {
    characterAddresses: Array<Scalars['String']['input']>;
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    feePayer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateCreateAssemblerConfigTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    order?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    ticker: Scalars['String']['input'];
    treeConfig?: InputMaybe<TreeSetupConfig>;
};
export type QueryCreateCreateCharacterModelTransactionArgs = {
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    config: CharacterConfigInput;
    cooldown?: InputMaybe<CharacterCooldownInput>;
    equipableCriteria?: InputMaybe<Array<Scalars['String']['input']>>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    mintAs?: InputMaybe<MintAsInput>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
};
export type QueryCreateCreateCharactersTreeTransactionArgs = {
    authority: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    treeConfig: TreeSetupConfig;
};
export type QueryCreateCreateDelegateAuthorityTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    delegate: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    serviceDelegations: ServiceDelegationInput;
};
export type QueryCreateCreateMissionPoolTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    data: NewMissionPoolData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateCreateMissionTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    data: NewMissionData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateCreateNewResourceTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    params: InitResourceInput;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
};
export type QueryCreateCreateNewResourceTreeTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    resource: Scalars['String']['input'];
    treeConfig: TreeSetupConfig;
};
export type QueryCreateCreateNewSplStakingPoolTreeTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    treeConfig: TreeSetupConfig;
};
export type QueryCreateCreateProfilesTreeTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
    treeConfig: TreeSetupConfig;
};
export type QueryCreateCreateProjectTransactionArgs = {
    associatedPrograms?: InputMaybe<Array<AssociatedProgramInput>>;
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    driver?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    name: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    profileDataConfig?: InputMaybe<ProfileDataConfigInput>;
    subsidizeFees?: InputMaybe<Scalars['Boolean']['input']>;
};
export type QueryCreateCreateSplStakingPoolTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    metadata: CreateSplStakingPoolMetadataInput;
    multipliers?: InputMaybe<Array<AddSplMultiplierMetadataInput>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    stakeTokenMint: Scalars['String']['input'];
};
export type QueryCreateCreateStakingPoolTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    metadata: CreateStakingPoolMetadataInput;
    multiplier?: InputMaybe<InitStakingMultiplierMetadataInput>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    resource: Scalars['String']['input'];
};
export type QueryCreateCreateUnwrapHoldingTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    resource: Scalars['String']['input'];
};
export type QueryCreateCreateWrapHoldingTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    resource: Scalars['String']['input'];
};
export type QueryCreateDismountResourceOnCharacterTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    characterAddress: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    resource: Scalars['String']['input'];
};
export type QueryCreateEquipResourceOnCharacterTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    characterAddress: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    resource: Scalars['String']['input'];
};
export type QueryCreateExportFungibleResourceTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    resource: Scalars['String']['input'];
};
export type QueryCreateImportFungibleResourceTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    params: ImportResourceInput;
};
export type QueryCreateInitCookingProcessTransactionsArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    recipe: Scalars['String']['input'];
};
export type QueryCreateInitMultipliersTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    decimals: Scalars['Int']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    multipliers: Array<InputMaybe<AddMultiplierMetadataInput>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    stakingPool: Scalars['String']['input'];
};
export type QueryCreateInitializeBadgeCriteriaTransactionArgs = {
    args: CreateBadgeCriteriaInput;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateInitializeFaucetTransactionArgs = {
    amount: Scalars['Int']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    repeatInterval: Scalars['Int']['input'];
    resource: Scalars['String']['input'];
};
export type QueryCreateInitializeRecipeTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    ingredients: Array<IngredientsInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    meal: MealInput;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    xp: Scalars['BigInt']['input'];
};
export type QueryCreateMintResourceTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    resource: Scalars['String']['input'];
};
export type QueryCreateModifyDelegationTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    delegate: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    modifyDelegation: ModifyDelegationInput;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
};
export type QueryCreateNewProfileTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    identity?: InputMaybe<Scalars['String']['input']>;
    info?: InputMaybe<ProfileInfoInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
};
export type QueryCreateNewUserBulkTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    info: Array<UserInfoInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    wallet: Array<Scalars['String']['input']>;
};
export type QueryCreateNewUserTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    info?: InputMaybe<UserInfoInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    wallet: Scalars['String']['input'];
};
export type QueryCreateNewUserWithProfileTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    profileIdentity?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    userInfo: UserInfoInput;
    wallet: Scalars['String']['input'];
};
export type QueryCreatePopulateCharacterTransactionArgs = {
    assemblerConfig?: InputMaybe<Scalars['String']['input']>;
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    mint: Scalars['String']['input'];
    owner: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
    updateAuthority: Scalars['String']['input'];
};
export type QueryCreateRecallCharactersTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    data: RecallFromMissionData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateRemoveCharacterTraitsTransactionsArgs = {
    assemblerConfig: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    traitsAddresses: Array<Scalars['String']['input']>;
};
export type QueryCreateRemoveIngredientsTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    ingredients: Array<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    recipe: Scalars['String']['input'];
};
export type QueryCreateSendCharactersOnMissionTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    data: ParticipateOnMissionData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateSplRewardPoolTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    rewardConfig: CreateSplRewardPoolArgsInput;
    rewardTokenMint: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
};
export type QueryCreateStakeCharactersTransactionsArgs = {
    characterAddresses: Array<Scalars['String']['input']>;
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    feePayer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    project: Scalars['String']['input'];
    stakingPool: Scalars['String']['input'];
};
export type QueryCreateStakeSplTokensTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lockPeriodSecs: Scalars['BigInt']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    staker: Scalars['String']['input'];
};
export type QueryCreateTransferAssetsTransactionsArgs = {
    addresses: Array<Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    to: Scalars['String']['input'];
};
export type QueryCreateTransferResourceTransactionArgs = {
    amount: Scalars['BigInt']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    recipient: Scalars['String']['input'];
    resource: Scalars['String']['input'];
};
export type QueryCreateUnstakeCharactersTransactionsArgs = {
    characterAddresses: Array<Scalars['String']['input']>;
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    feePayer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateUnstakeSplTokensTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    staker: Scalars['String']['input'];
    stakingReciept: Scalars['String']['input'];
};
export type QueryCreateUnwrapAssetsFromCharacterTransactionsArgs = {
    characterAddresses: Array<Scalars['String']['input']>;
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    libreplexDeployment?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    project: Scalars['String']['input'];
    wallet: Scalars['String']['input'];
};
export type QueryCreateUpdateBadgeCriteriaTransactionArgs = {
    args: UpdateBadgeCriteriaInput;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateUpdateCharacterTraitsTransactionArgs = {
    assemblerConfig: Scalars['String']['input'];
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    authority: Scalars['String']['input'];
    characterAddress: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    uri?: InputMaybe<Scalars['String']['input']>;
};
export type QueryCreateUpdateMissionPoolTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    data: UpdateMissionPoolData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryCreateUpdateMissionTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    missionAddress: Scalars['String']['input'];
    params: UpdateMissionInput;
    payer?: InputMaybe<Scalars['String']['input']>;
};
export type QueryCreateUpdatePlatformDataTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    platformData?: InputMaybe<PlatformDataInput>;
    profile: Scalars['String']['input'];
};
export type QueryCreateUpdateProfileTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    customData?: InputMaybe<CustomDataInput>;
    info?: InputMaybe<ProfileInfoInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    profile: Scalars['String']['input'];
};
export type QueryCreateUpdateSplStakingPoolTransactionArgs = {
    authority: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    metadata: UpdateSplStakingPoolMetadataInput;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
};
export type QueryCreateUpdateStakingPoolTransactionArgs = {
    authority: Scalars['String']['input'];
    characterModel?: InputMaybe<Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    metadata?: InputMaybe<UpdateStakingPoolMetadataInput>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    resource?: InputMaybe<Scalars['String']['input']>;
    stakingPool: Scalars['String']['input'];
};
export type QueryCreateUpdateUserTransactionArgs = {
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    info?: InputMaybe<PartialUserInfoInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer: Scalars['String']['input'];
    populateCivic?: InputMaybe<Scalars['Boolean']['input']>;
    removeSocials?: InputMaybe<Array<RemoveSocialsInput>>;
    wallets?: InputMaybe<UpdateWalletInput>;
};
export type QueryCreateUseCharacterTransactionArgs = {
    character: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    data?: InputMaybe<Scalars['JSON']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    unUse?: InputMaybe<Scalars['Boolean']['input']>;
    user: Scalars['String']['input'];
};
export type QueryCreateWrapAssetsToCharacterTransactionsArgs = {
    characterModel: Scalars['String']['input'];
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    libreplexDeployment?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']>>;
    mintList: Array<Scalars['String']['input']>;
    project: Scalars['String']['input'];
    wallet: Scalars['String']['input'];
};
export type QueryDelegateAuthorityArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    delegates?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryFaucetsArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    resources?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryGlobalArgs = {
    env?: InputMaybe<Scalars['String']['input']>;
};
export type QueryHoldingsArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    holders?: InputMaybe<Array<InputMaybe<Scalars['Pubkey']['input']>>>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']>>;
};
export type QueryMissionArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    missionPools?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryMissionPoolArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    project?: InputMaybe<Scalars['Pubkey']['input']>;
};
export type QueryMultipliersArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    stakingPools?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryProfileArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    identities?: InputMaybe<Array<Scalars['String']['input']>>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    includeUsers?: InputMaybe<Scalars['Boolean']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    userIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};
export type QueryProjectArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    authorities?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    names?: InputMaybe<Array<Scalars['String']['input']>>;
};
export type QueryProofArgs = {
    leaves: Array<TreeLeaf>;
};
export type QueryRecipesArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryResourcesArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    mints?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryResourcesBalanceArgs = {
    addresses?: InputMaybe<Array<Scalars['String']['input']>>;
    mints?: InputMaybe<Array<Scalars['String']['input']>>;
    projects?: InputMaybe<Array<Scalars['String']['input']>>;
    wallets: Array<Scalars['String']['input']>;
};
export type QuerySendBulkTransactionsArgs = {
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
    txs: Array<Scalars['Bytes']['input']>;
};
export type QuerySendTransactionBundlesArgs = {
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
    txs: Array<Scalars['Bytes']['input']>;
};
export type QuerySignWithShadowSignerAndSendBulkTransactionsArgs = {
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
    txs: Array<Scalars['Bytes']['input']>;
};
export type QuerySignWithShadowSignerAndSendTransactionBundlesArgs = {
    authToken: Scalars['String']['input'];
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
    txs: Array<Scalars['Bytes']['input']>;
};
export type QuerySplStakingPoolsArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    names?: InputMaybe<Array<Scalars['String']['input']>>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    stakeTokenMints?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QuerySplStakingRecipientsArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    projects?: InputMaybe<Array<Scalars['String']['input']>>;
    splStakingPools?: InputMaybe<Array<Scalars['String']['input']>>;
    stakers?: InputMaybe<Array<Scalars['String']['input']>>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']>>;
};
export type QueryStakersArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    stakingPools?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
    wallets?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryStakingPoolsArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    names?: InputMaybe<Array<Scalars['String']['input']>>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type QueryUserArgs = {
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    ids?: InputMaybe<Array<Scalars['Int']['input']>>;
    includeProjectProfiles?: InputMaybe<Array<InputMaybe<Scalars['Pubkey']['input']>>>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    wallets?: InputMaybe<Array<Scalars['Pubkey']['input']>>;
};
export type RecallFromMissionData = {
    authority: Scalars['String']['input'];
    characterAddresses: Array<Scalars['String']['input']>;
    mission: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    userId?: InputMaybe<Scalars['Int']['input']>;
};
export type Recipe = {
    __typename?: 'Recipe';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    ingredients: Array<Ingredient>;
    key: Scalars['Pubkey']['output'];
    meal: Meal;
    project: Scalars['Pubkey']['output'];
    xp: Scalars['BigInt']['output'];
};
export type RecipeInputResource = {
    amount: Scalars['Int']['input'];
    resource: Scalars['String']['input'];
};
export type RecipeInputResources = {
    inputFour?: InputMaybe<RecipeInputResource>;
    inputOne: RecipeInputResource;
    inputThree?: InputMaybe<RecipeInputResource>;
    inputTwo?: InputMaybe<RecipeInputResource>;
};
export type RecipeOutputResource = {
    amount: Scalars['Int']['input'];
    characteristics: Scalars['JSON']['input'];
    resource: Scalars['String']['input'];
};
export type RecipeResources = {
    input: RecipeInputResources;
    output: RecipeOutputResource;
};
export declare enum RemoveSocialsInput {
    All = "All",
    Discord = "Discord",
    Steam = "Steam",
    Twitter = "Twitter"
}
export type Resource = {
    __typename?: 'Resource';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    kind: ResourceKind;
    mint: Scalars['Pubkey']['output'];
    project: Scalars['Pubkey']['output'];
    storage: ResourceStorage;
    tags: Array<Scalars['String']['output']>;
};
export type ResourceBalance = {
    __typename?: 'ResourceBalance';
    address: Scalars['Bytes']['output'];
    amount: Scalars['String']['output'];
    mint: Scalars['Pubkey']['output'];
    resourceStorage: ResourceStorageEnum;
    wallet?: Maybe<Scalars['String']['output']>;
};
export type ResourceCustody = {
    __typename?: 'ResourceCustody';
    kind: ResourceCustodyEnum;
    params?: Maybe<ResourceCustodyParams>;
};
export declare enum ResourceCustodyEnum {
    Authority = "Authority",
    Supply = "Supply"
}
export type ResourceCustodyParams = {
    __typename?: 'ResourceCustodyParams';
    burnerDestination?: Maybe<Scalars['Pubkey']['output']>;
};
export type ResourceKind = {
    __typename?: 'ResourceKind';
    kind: Scalars['String']['output'];
    params?: Maybe<ResourceKindParams>;
};
export type ResourceKindParams = ResourceKindParamsHplFungible | ResourceKindParamsHplNonFungible | ResourceKindParamsWrappedFungible | ResourceKindParamsWrappedMplCore;
export type ResourceKindParamsHplFungible = {
    __typename?: 'ResourceKindParamsHplFungible';
    decimals: Scalars['Int']['output'];
};
export type ResourceKindParamsHplNonFungible = {
    __typename?: 'ResourceKindParamsHplNonFungible';
    characteristics: Array<Maybe<Scalars['String']['output']>>;
};
export type ResourceKindParamsWrappedFungible = {
    __typename?: 'ResourceKindParamsWrappedFungible';
    custody: ResourceCustody;
    decimals: Scalars['Int']['output'];
};
export type ResourceKindParamsWrappedMplCore = {
    __typename?: 'ResourceKindParamsWrappedMplCore';
    characteristics: Array<Maybe<Scalars['String']['output']>>;
};
export declare enum ResourceManagerPermissionInput {
    BurnResources = "BurnResources",
    CreateFaucet = "CreateFaucet",
    CreateRecipe = "CreateRecipe",
    CreateResources = "CreateResources",
    MintResources = "MintResources"
}
export type ResourceRewardType = {
    __typename?: 'ResourceRewardType';
    kind: Scalars['String']['output'];
    params: ResourceRewardTypeParams;
};
export type ResourceRewardTypeParams = {
    __typename?: 'ResourceRewardTypeParams';
    address: Scalars['Pubkey']['output'];
};
export type ResourceStorage = {
    __typename?: 'ResourceStorage';
    kind: ResourceStorageEnum;
    params?: Maybe<ResourceStorageParams>;
};
export declare enum ResourceStorageEnum {
    AccountState = "AccountState",
    LedgerState = "LedgerState"
}
export type ResourceStorageParams = {
    __typename?: 'ResourceStorageParams';
    merkle_trees: ControlledMerkleTrees;
    promiseSupply: Scalars['BigInt']['output'];
};
export type Reward = {
    __typename?: 'Reward';
    max: Scalars['BigInt']['output'];
    min: Scalars['BigInt']['output'];
    rewardType?: Maybe<RewardType>;
};
export declare enum RewardKind {
    Resource = "Resource",
    Xp = "Xp"
}
export type RewardPoolConfigApyInput = {
    rewardsDuration: Scalars['BigInt']['input'];
    rewardsPerDuration: Scalars['BigInt']['input'];
};
export type RewardType = ResourceRewardType | XpRewardType;
export type SendTransactionBundlesOptions = {
    bundles?: InputMaybe<TransactionBundlesOptions>;
    commitment?: InputMaybe<Scalars['String']['input']>;
    skipPreflight?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SendTransactionsOptions = {
    commitment?: InputMaybe<Scalars['String']['input']>;
    skipPreflight?: InputMaybe<Scalars['Boolean']['input']>;
};
export type SerializableActions = {
    __typename?: 'SerializableActions';
    kind: Scalars['String']['output'];
};
export type SerializableActionsInput = {
    kind: Scalars['String']['input'];
};
export type Service = {
    __typename?: 'Service';
    kind: Scalars['String']['output'];
    params?: Maybe<ServiceParams>;
};
export type ServiceDelegation = {
    __typename?: 'ServiceDelegation';
    index?: Maybe<Scalars['Int']['output']>;
    kind: Scalars['String']['output'];
    permission: Scalars['String']['output'];
};
export type ServiceDelegationBuzzGuild = {
    index: Scalars['Int']['input'];
    permission: BuzzGuildPermissionInput;
};
export type ServiceDelegationCharacterManager = {
    index: Scalars['Int']['input'];
    permission: CharacterManagerPermissionInput;
};
export type ServiceDelegationHiveControl = {
    permission: HiveControlPermissionInput;
};
export type ServiceDelegationInput = {
    BuzzGuild?: InputMaybe<Array<ServiceDelegationBuzzGuild>>;
    CharacterManager?: InputMaybe<Array<ServiceDelegationCharacterManager>>;
    HiveControl?: InputMaybe<Array<ServiceDelegationHiveControl>>;
    NectarMissions?: InputMaybe<Array<ServiceDelegationNectarMissions>>;
    NectarStaking?: InputMaybe<Array<ServiceDelegationNectarStaking>>;
    ResourceManager?: InputMaybe<Array<ServiceDelegationResourceManager>>;
};
export type ServiceDelegationNectarMissions = {
    index: Scalars['Int']['input'];
    permission: NectarMissionsPermissionInput;
};
export type ServiceDelegationNectarStaking = {
    index: Scalars['Int']['input'];
    permission: NectarStakingPermissionInput;
};
export type ServiceDelegationResourceManager = {
    permission: ResourceManagerPermissionInput;
};
export type ServiceParams = ServiceParamsAssembler | ServiceParamsAssetManager | ServiceParamsGuildKit | ServiceParamsMissions | ServiceParamsRaffles | ServiceParamsStaking;
export type ServiceParamsAssembler = {
    __typename?: 'ServiceParamsAssembler';
    assemblerId: Scalars['Pubkey']['output'];
};
export type ServiceParamsAssetManager = {
    __typename?: 'ServiceParamsAssetManager';
    assetManagerId: Scalars['Pubkey']['output'];
};
export type ServiceParamsGuildKit = {
    __typename?: 'ServiceParamsGuildKit';
    kitId: Scalars['Pubkey']['output'];
};
export type ServiceParamsMissions = {
    __typename?: 'ServiceParamsMissions';
    poolId: Scalars['Pubkey']['output'];
};
export type ServiceParamsRaffles = {
    __typename?: 'ServiceParamsRaffles';
    poolId: Scalars['Pubkey']['output'];
};
export type ServiceParamsStaking = {
    __typename?: 'ServiceParamsStaking';
    poolId: Scalars['Pubkey']['output'];
};
export type SocialInfo = {
    __typename?: 'SocialInfo';
    civic?: Maybe<Array<Maybe<CivicInfo>>>;
    discord?: Maybe<Scalars['String']['output']>;
    steam?: Maybe<Scalars['String']['output']>;
    twitter?: Maybe<Scalars['String']['output']>;
};
export declare enum SourceKind {
    Assembled = "Assembled",
    MplBubblegum = "MplBubblegum",
    MplCoreAsset = "MplCoreAsset",
    MplMetadata = "MplMetadata",
    TokenExtensions = "TokenExtensions"
}
export type SplMultiplier = {
    __typename?: 'SplMultiplier';
    multiplierType: SplMultiplierType;
    value: Scalars['BigInt']['output'];
};
export type SplMultiplierInput = {
    minAmount?: InputMaybe<Scalars['BigInt']['input']>;
    minDuration?: InputMaybe<Scalars['BigInt']['input']>;
};
export type SplMultiplierType = {
    __typename?: 'SplMultiplierType';
    kind: Scalars['String']['output'];
    params: SplMultiplierTypeParams;
};
export type SplMultiplierTypeParams = SplMultiplierTypeParamsStakeAmount | SplMultiplierTypeParamsStakeDuration;
export type SplMultiplierTypeParamsStakeAmount = {
    __typename?: 'SplMultiplierTypeParamsStakeAmount';
    minAmount: Scalars['BigInt']['output'];
};
export type SplMultiplierTypeParamsStakeDuration = {
    __typename?: 'SplMultiplierTypeParamsStakeDuration';
    minDuration: Scalars['BigInt']['output'];
};
export type SplRewardConfig = {
    __typename?: 'SplRewardConfig';
    kind: Scalars['String']['output'];
    params?: Maybe<SplRewardConfigParams>;
};
export type SplRewardConfigParams = SplRewardConfigParamsApy | SplRewardConfigParamsNotSet | SplRewardConfigParamsStakeWeight;
export type SplRewardConfigParamsApy = {
    __typename?: 'SplRewardConfigParamsApy';
    rewardTokenMint?: Maybe<Scalars['Pubkey']['output']>;
    rewardVault?: Maybe<Scalars['Pubkey']['output']>;
    rewardsDuration: Scalars['BigInt']['output'];
    rewardsPerDuration: Scalars['BigInt']['output'];
    totalRewardAmount: Scalars['BigInt']['output'];
};
export type SplRewardConfigParamsNotSet = {
    __typename?: 'SplRewardConfigParamsNotSet';
    notSet?: Maybe<Scalars['Boolean']['output']>;
};
export type SplRewardConfigParamsStakeWeight = {
    __typename?: 'SplRewardConfigParamsStakeWeight';
    pools: Array<SplStakeWeightConfig>;
};
export type SplStakeWeightConfig = {
    __typename?: 'SplStakeWeightConfig';
    weight: Scalars['Int']['output'];
};
export type SplStakingPool = {
    __typename?: 'SplStakingPool';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    endTime?: Maybe<Scalars['BigInt']['output']>;
    maxStakeDurationSecs?: Maybe<Scalars['BigInt']['output']>;
    merkleTrees: ControlledMerkleTrees;
    minStakeDurationSecs?: Maybe<Scalars['BigInt']['output']>;
    multipliers: Array<SplMultiplier>;
    name: Scalars['String']['output'];
    nonce?: Maybe<Scalars['Int']['output']>;
    project: Scalars['Pubkey']['output'];
    rewardConfig: SplRewardConfig;
    stake_token_mint: Scalars['Pubkey']['output'];
    startTime?: Maybe<Scalars['BigInt']['output']>;
    totalStakedAmount: Scalars['BigInt']['output'];
};
export type Staker = {
    __typename?: 'Staker';
    address: Scalars['Bytes']['output'];
    bump: Scalars['Int']['output'];
    stakingPool: Scalars['Pubkey']['output'];
    totalStaked: Scalars['BigInt']['output'];
    wallet: Scalars['Pubkey']['output'];
};
export type StakerClaimed = {
    __typename?: 'StakerClaimed';
    kind: Scalars['String']['output'];
    params?: Maybe<StakerClaimedParams>;
};
export type StakerClaimedParams = StakerClaimedParamsApy | StakerClaimedParamsNone | StakerClaimedParamsStakeWeight;
export type StakerClaimedParamsApy = {
    __typename?: 'StakerClaimedParamsApy';
    lastRewardTime: Scalars['BigInt']['output'];
};
export type StakerClaimedParamsNone = {
    __typename?: 'StakerClaimedParamsNone';
    none?: Maybe<Scalars['Boolean']['output']>;
};
export type StakerClaimedParamsStakeWeight = {
    __typename?: 'StakerClaimedParamsStakeWeight';
    amounts: Array<Maybe<Scalars['BigInt']['output']>>;
};
export type StakingPool = {
    __typename?: 'StakingPool';
    address: Scalars['Bytes']['output'];
    allowedMints: Scalars['Boolean']['output'];
    bump: Scalars['Int']['output'];
    characterModels: Array<Maybe<Scalars['Pubkey']['output']>>;
    cooldownDuration?: Maybe<Scalars['BigInt']['output']>;
    endTime?: Maybe<Scalars['BigInt']['output']>;
    key: Scalars['Pubkey']['output'];
    lockType: LockType;
    maxRewardsDuration?: Maybe<Scalars['BigInt']['output']>;
    minStakeDuration?: Maybe<Scalars['BigInt']['output']>;
    name: Scalars['String']['output'];
    project: Scalars['Pubkey']['output'];
    resetStakeDuration: Scalars['Boolean']['output'];
    resource: Scalars['Pubkey']['output'];
    rewardsDuration: Scalars['BigInt']['output'];
    rewardsPerDuration: Scalars['BigInt']['output'];
    startTime?: Maybe<Scalars['BigInt']['output']>;
    totalStaked: Scalars['BigInt']['output'];
};
export type StakingRecipient = {
    __typename?: 'StakingRecipient';
    address: Scalars['Bytes']['output'];
    leaf_idx: Scalars['BigInt']['output'];
    lokedTill: Scalars['BigInt']['output'];
    multiplier: Scalars['Int']['output'];
    proof?: Maybe<Proof>;
    rewardsClaimed: StakerClaimed;
    stakeStartTime: Scalars['BigInt']['output'];
    stakedAmount: Scalars['BigInt']['output'];
    staker: Scalars['Pubkey']['output'];
    tree_id: Scalars['Bytes']['output'];
};
export type TimeRequirement = {
    __typename?: 'TimeRequirement';
    kind: Scalars['String']['output'];
    params: TimeRequirementParams;
};
export type TimeRequirementParams = {
    __typename?: 'TimeRequirementParams';
    duration: Scalars['BigInt']['output'];
};
export type Transaction = {
    __typename?: 'Transaction';
    blockhash: Scalars['String']['output'];
    lastValidBlockHeight: Scalars['Int']['output'];
    transaction: Scalars['Bytes']['output'];
};
export type TransactionBundleResponse = {
    __typename?: 'TransactionBundleResponse';
    bundleId: Scalars['Int']['output'];
    responses: Array<TransactionResponse>;
};
export type TransactionBundlesOptions = {
    bundleSize?: InputMaybe<Scalars['Int']['input']>;
    firstBundleSize?: InputMaybe<Scalars['Int']['input']>;
    lastBundleSize?: InputMaybe<Scalars['Int']['input']>;
};
export type TransactionResponse = {
    __typename?: 'TransactionResponse';
    error?: Maybe<Scalars['JSON']['output']>;
    signature?: Maybe<Scalars['String']['output']>;
    status: Scalars['String']['output'];
};
export type Transactions = {
    __typename?: 'Transactions';
    blockhash: Scalars['String']['output'];
    lastValidBlockHeight: Scalars['Int']['output'];
    transactions: Array<Scalars['Bytes']['output']>;
};
export type TreeLeaf = {
    index?: InputMaybe<Scalars['BigInt']['input']>;
    tree: Scalars['Bytes']['input'];
};
export type TreeSetupConfig = {
    advanced?: InputMaybe<AdvancedTreeConfig>;
    basic?: InputMaybe<BasicTreeConfig>;
};
export type TreeSetupResponse = {
    __typename?: 'TreeSetupResponse';
    cost?: Maybe<Scalars['Float']['output']>;
    maxTreeCapacity: Scalars['Int']['output'];
    proofBytes: Scalars['Int']['output'];
    space: Scalars['Int']['output'];
    treeAddress: Scalars['Bytes']['output'];
    tx: Transaction;
};
export type UpdateBadgeCriteriaInput = {
    authority: Scalars['Pubkey']['input'];
    condition: BadgesCondition;
    criteriaIndex: Scalars['Int']['input'];
    endTime?: InputMaybe<Scalars['Int']['input']>;
    payer?: InputMaybe<Scalars['Pubkey']['input']>;
    projectAddress: Scalars['Pubkey']['input'];
    startTime?: InputMaybe<Scalars['Int']['input']>;
};
export type UpdateMissionData = {
    addRewards?: InputMaybe<Array<MissionReward>>;
    authority: Scalars['String']['input'];
    cost?: InputMaybe<NewMissionCost>;
    duration?: InputMaybe<Scalars['BigInt']['input']>;
    minXp?: InputMaybe<Scalars['BigInt']['input']>;
    mission: Scalars['String']['input'];
    name?: InputMaybe<Scalars['String']['input']>;
    payer?: InputMaybe<Scalars['String']['input']>;
    removeAllRewards?: InputMaybe<Scalars['Boolean']['input']>;
    removeRewardIndices?: InputMaybe<Array<Scalars['Int']['input']>>;
};
export type UpdateMissionInput = {
    cost?: InputMaybe<NewMissionCost>;
    duration?: InputMaybe<Scalars['BigInt']['input']>;
    minXp?: InputMaybe<Scalars['BigInt']['input']>;
    newRewards?: InputMaybe<Array<MissionReward>>;
    removeRewards?: InputMaybe<Array<Scalars['Int']['input']>>;
    updateRewards?: InputMaybe<Array<MissionReward>>;
};
export type UpdateMissionPoolData = {
    authority: Scalars['String']['input'];
    characterModel?: InputMaybe<Scalars['String']['input']>;
    missionPool: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    project: Scalars['String']['input'];
};
export type UpdateSplStakingPoolMetadataInput = {
    endTime?: InputMaybe<Scalars['BigInt']['input']>;
    maxStakeDurationSecs?: InputMaybe<Scalars['BigInt']['input']>;
    minStakeDurationSecs?: InputMaybe<Scalars['BigInt']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    startTime?: InputMaybe<Scalars['BigInt']['input']>;
};
export type UpdateStakingPoolMetadataInput = {
    cooldownDuration?: InputMaybe<Scalars['BigInt']['input']>;
    endTime?: InputMaybe<Scalars['BigInt']['input']>;
    maxRewardsDuration?: InputMaybe<Scalars['BigInt']['input']>;
    minStakeDuration?: InputMaybe<Scalars['BigInt']['input']>;
    name?: InputMaybe<Scalars['String']['input']>;
    resetStakeDuration?: InputMaybe<Scalars['Boolean']['input']>;
    rewardsDuration?: InputMaybe<Scalars['BigInt']['input']>;
    rewardsPerDuration?: InputMaybe<Scalars['BigInt']['input']>;
    startTime?: InputMaybe<Scalars['BigInt']['input']>;
};
export type UpdateWalletInput = {
    add?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
    remove?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};
export type UsedByCustom = {
    __typename?: 'UsedByCustom';
    data: Scalars['JSON']['output'];
    user: Scalars['Pubkey']['output'];
};
export type UsedByEjected = {
    __typename?: 'UsedByEjected';
    mint: Scalars['Pubkey']['output'];
};
export type UsedByGuild = {
    __typename?: 'UsedByGuild';
    id: Scalars['Pubkey']['output'];
    order: Scalars['Int']['output'];
    role: GuildRole;
};
export type UsedByGuildFilter = {
    id?: InputMaybe<Scalars['Pubkey']['input']>;
    order?: InputMaybe<Scalars['Int']['input']>;
    role?: InputMaybe<GuildRoleFilter>;
};
export type UsedByMission = {
    __typename?: 'UsedByMission';
    endTime: Scalars['Int']['output'];
    missionId: Scalars['Pubkey']['output'];
    participationId: Scalars['String']['output'];
    rewards: Array<EarnedRewards>;
};
export type UsedByStaking = {
    __typename?: 'UsedByStaking';
    claimedAt: Scalars['Int']['output'];
    pool: Scalars['Pubkey']['output'];
    stakedAt: Scalars['Int']['output'];
    staker: Scalars['Pubkey']['output'];
};
export type User = {
    __typename?: 'User';
    address: Scalars['Bytes']['output'];
    id: Scalars['Int']['output'];
    info: UserInfo;
    leaf_idx: Scalars['BigInt']['output'];
    profiles?: Maybe<Array<Maybe<Profile>>>;
    proof?: Maybe<Proof>;
    socialInfo: SocialInfo;
    tree_id: Scalars['Bytes']['output'];
    wallets: Wallets;
};
export type UserInfo = {
    __typename?: 'UserInfo';
    bio: Scalars['String']['output'];
    name: Scalars['String']['output'];
    pfp: Scalars['String']['output'];
    username: Scalars['String']['output'];
};
export type UserInfoInput = {
    bio: Scalars['String']['input'];
    name: Scalars['String']['input'];
    pfp: Scalars['String']['input'];
};
export type Wallets = {
    __typename?: 'Wallets';
    shadow: Scalars['Pubkey']['output'];
    wallets: Array<Scalars['Pubkey']['output']>;
};
export type Wrapped = {
    __typename?: 'Wrapped';
    criteria: AssetCriteria;
    kind?: Maybe<SourceKind>;
    mint: Scalars['Pubkey']['output'];
};
export type XpRewardType = {
    __typename?: 'XpRewardType';
    kind: Scalars['String']['output'];
};
export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;
export type ResolverTypeWrapper<T> = Promise<T> | T;
export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;
export type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;
export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;
export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{
        [key in TKey]: TResult;
    }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, {
        [key in TKey]: TResult;
    }, TContext, TArgs>;
}
export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}
export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;
export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;
export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;
export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;
export type NextResolverFn<T> = () => Promise<T>;
export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
export type ResolversUnionTypes<_RefType extends Record<string, unknown>> = ResolversObject<{
    CharacterConfig: (Omit<CharacterConfigAssembled, 'mintAs'> & {
        mintAs: _RefType['MintAs'];
    }) | (CharacterConfigWrapped);
    CharacterSourceParams: (Assembled) | (Wrapped);
    CharacterUsedByParams: (UsedByCustom) | (UsedByEjected) | (UsedByGuild) | (UsedByMission) | (UsedByStaking);
    MintAsParams: (MintAsParamsMplBubblegum);
    MissionRequirement: (TimeRequirement);
    MultiplierTypeParams: (MultiplierTypeParamsCollection) | (MultiplierTypeParamsCreator) | (MultiplierTypeParamsNftCount) | (MultiplierTypeParamsStakeDuration);
    OutputHolding: (Holding) | (OutputHoldingTree);
    ResourceKindParams: (ResourceKindParamsHplFungible) | (ResourceKindParamsHplNonFungible) | (ResourceKindParamsWrappedFungible) | (ResourceKindParamsWrappedMplCore);
    RewardType: (ResourceRewardType) | (XpRewardType);
    ServiceParams: (ServiceParamsAssembler) | (ServiceParamsAssetManager) | (ServiceParamsGuildKit) | (ServiceParamsMissions) | (ServiceParamsRaffles) | (ServiceParamsStaking);
    SplMultiplierTypeParams: (SplMultiplierTypeParamsStakeAmount) | (SplMultiplierTypeParamsStakeDuration);
    SplRewardConfigParams: (SplRewardConfigParamsApy) | (SplRewardConfigParamsNotSet) | (SplRewardConfigParamsStakeWeight);
    StakerClaimedParams: (StakerClaimedParamsApy) | (StakerClaimedParamsNone) | (StakerClaimedParamsStakeWeight);
}>;
export type ResolversTypes = ResolversObject<{
    Account: ResolverTypeWrapper<Account>;
    AddMultiplierMetadataInput: AddMultiplierMetadataInput;
    AddRemoveRewardsFromRewardPoolActionInput: AddRemoveRewardsFromRewardPoolActionInput;
    AddSplMultiplierMetadataInput: AddSplMultiplierMetadataInput;
    AdvancedTreeConfig: AdvancedTreeConfig;
    Int: ResolverTypeWrapper<Scalars['Int']['output']>;
    Assembled: ResolverTypeWrapper<Assembled>;
    String: ResolverTypeWrapper<Scalars['String']['output']>;
    AssemblerConfig: ResolverTypeWrapper<AssemblerConfig>;
    AssemblerConfigInput: AssemblerConfigInput;
    AssetCriteria: ResolverTypeWrapper<AssetCriteria>;
    AssetCriteriaFilter: AssetCriteriaFilter;
    AssetCriteriaInput: AssetCriteriaInput;
    AssetCriteriaKind: AssetCriteriaKind;
    AssociatedProgram: ResolverTypeWrapper<AssociatedProgram>;
    AssociatedProgramInput: AssociatedProgramInput;
    AuthConfirmed: ResolverTypeWrapper<AuthConfirmed>;
    AuthResponse: ResolverTypeWrapper<AuthResponse>;
    BadgeCriteria: ResolverTypeWrapper<BadgeCriteria>;
    BadgesCondition: BadgesCondition;
    BasicTreeConfig: BasicTreeConfig;
    BigInt: ResolverTypeWrapper<Scalars['BigInt']['output']>;
    BuzzGuildPermissionInput: BuzzGuildPermissionInput;
    Bytes: ResolverTypeWrapper<Scalars['Bytes']['output']>;
    Character: ResolverTypeWrapper<Omit<Character, 'source' | 'usedBy'> & {
        source: ResolversTypes['CharacterSource'];
        usedBy: ResolversTypes['CharacterUsedBy'];
    }>;
    CharacterConfig: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CharacterConfig']>;
    CharacterConfigAssembled: ResolverTypeWrapper<Omit<CharacterConfigAssembled, 'mintAs'> & {
        mintAs: ResolversTypes['MintAs'];
    }>;
    CharacterConfigInput: CharacterConfigInput;
    CharacterConfigWrapped: ResolverTypeWrapper<CharacterConfigWrapped>;
    CharacterCooldown: ResolverTypeWrapper<CharacterCooldown>;
    CharacterCooldownInput: CharacterCooldownInput;
    CharacterHistory: ResolverTypeWrapper<CharacterHistory>;
    CharacterManagerPermissionInput: CharacterManagerPermissionInput;
    CharacterModel: ResolverTypeWrapper<Omit<CharacterModel, 'config'> & {
        config: ResolversTypes['CharacterConfig'];
    }>;
    CharacterSource: ResolverTypeWrapper<Omit<CharacterSource, 'params'> & {
        params: ResolversTypes['CharacterSourceParams'];
    }>;
    CharacterSourceFilter: CharacterSourceFilter;
    CharacterSourceKind: CharacterSourceKind;
    CharacterSourceParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CharacterSourceParams']>;
    CharacterSourceParamsFilter: CharacterSourceParamsFilter;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
    CharacterTrait: ResolverTypeWrapper<CharacterTrait>;
    CharacterTraitInput: CharacterTraitInput;
    CharacterUsedBy: ResolverTypeWrapper<Omit<CharacterUsedBy, 'params'> & {
        params?: Maybe<ResolversTypes['CharacterUsedByParams']>;
    }>;
    CharacterUsedByFilter: CharacterUsedByFilter;
    CharacterUsedByParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['CharacterUsedByParams']>;
    CharacterUsedByParamsFilter: CharacterUsedByParamsFilter;
    CharactersFilter: CharactersFilter;
    CivicGateway: CivicGateway;
    CivicInfo: ResolverTypeWrapper<CivicInfo>;
    CivicInfoInput: CivicInfoInput;
    ClaimBadgeCriteriaInput: ClaimBadgeCriteriaInput;
    CompressedAccount: ResolverTypeWrapper<CompressedAccount>;
    ControlledMerkleTrees: ResolverTypeWrapper<ControlledMerkleTrees>;
    CreateAssemblerConfigTransactionResponse: ResolverTypeWrapper<CreateAssemblerConfigTransactionResponse>;
    Float: ResolverTypeWrapper<Scalars['Float']['output']>;
    CreateBadgeCriteriaInput: CreateBadgeCriteriaInput;
    CreateBeginCookingTransactionResponse: ResolverTypeWrapper<CreateBeginCookingTransactionResponse>;
    CreateCharacterModelTransactionResponse: ResolverTypeWrapper<CreateCharacterModelTransactionResponse>;
    CreateCreateHolderAccountTransactionResponse: ResolverTypeWrapper<CreateCreateHolderAccountTransactionResponse>;
    CreateCreateMissionPoolTransactionResponse: ResolverTypeWrapper<CreateCreateMissionPoolTransactionResponse>;
    CreateCreateMissionTransactionResponse: ResolverTypeWrapper<CreateCreateMissionTransactionResponse>;
    CreateCreateNewResourceTreeTransactionResponse: ResolverTypeWrapper<CreateCreateNewResourceTreeTransactionResponse>;
    CreateCreateProjectTransactionResponse: ResolverTypeWrapper<CreateCreateProjectTransactionResponse>;
    CreateCreateSplStakingPoolTransactionResponse: ResolverTypeWrapper<CreateCreateSplStakingPoolTransactionResponse>;
    CreateCreateStakingPoolTransactionResponse: ResolverTypeWrapper<CreateCreateStakingPoolTransactionResponse>;
    CreateInitMultipliersTransactionResponse: ResolverTypeWrapper<CreateInitMultipliersTransactionResponse>;
    CreateInitResourceTransactionResponse: ResolverTypeWrapper<CreateInitResourceTransactionResponse>;
    CreateInitializeFaucetTransactionResponse: ResolverTypeWrapper<CreateInitializeFaucetTransactionResponse>;
    CreateInitializeRecipeTransactionResponse: ResolverTypeWrapper<CreateInitializeRecipeTransactionResponse>;
    CreateSplRewardPoolArgsInput: CreateSplRewardPoolArgsInput;
    CreateSplStakingPoolMetadataInput: CreateSplStakingPoolMetadataInput;
    CreateStakingPoolMetadataInput: CreateStakingPoolMetadataInput;
    CreateUpdateMissionPoolTransactionResponse: ResolverTypeWrapper<CreateUpdateMissionPoolTransactionResponse>;
    CreateUpdateMissionTransactionResponse: ResolverTypeWrapper<CreateUpdateMissionTransactionResponse>;
    CustomDataInput: CustomDataInput;
    DelegateAuthority: ResolverTypeWrapper<DelegateAuthority>;
    DisrcriminatorFilter: DisrcriminatorFilter;
    EarnedRewards: ResolverTypeWrapper<EarnedRewards>;
    EarnedRewardsFilter: EarnedRewardsFilter;
    Faucet: ResolverTypeWrapper<Faucet>;
    Global: ResolverTypeWrapper<Global>;
    GuildRole: ResolverTypeWrapper<GuildRole>;
    GuildRoleFilter: GuildRoleFilter;
    HiveControlPermissionInput: HiveControlPermissionInput;
    Holding: ResolverTypeWrapper<Holding>;
    ImportResourceInput: ImportResourceInput;
    ImportResourceInputCustodyInput: ImportResourceInputCustodyInput;
    Ingredient: ResolverTypeWrapper<Ingredient>;
    IngredientsInput: IngredientsInput;
    InitResourceInput: InitResourceInput;
    InitStakingMultiplierMetadataInput: InitStakingMultiplierMetadataInput;
    JSON: ResolverTypeWrapper<Scalars['JSON']['output']>;
    LockType: ResolverTypeWrapper<LockType>;
    LockTypeEnum: LockTypeEnum;
    Meal: ResolverTypeWrapper<Meal>;
    MealInput: MealInput;
    MintAs: ResolverTypeWrapper<Omit<MintAs, 'params'> & {
        params?: Maybe<ResolversTypes['MintAsParams']>;
    }>;
    MintAsInput: MintAsInput;
    MintAsKind: MintAsKind;
    MintAsMplBubblegumInput: MintAsMplBubblegumInput;
    MintAsParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['MintAsParams']>;
    MintAsParamsMplBubblegum: ResolverTypeWrapper<MintAsParamsMplBubblegum>;
    Mission: ResolverTypeWrapper<Omit<Mission, 'requirement' | 'rewards'> & {
        requirement: ResolversTypes['MissionRequirement'];
        rewards: Array<Maybe<ResolversTypes['Reward']>>;
    }>;
    MissionCost: ResolverTypeWrapper<MissionCost>;
    MissionPool: ResolverTypeWrapper<MissionPool>;
    MissionRequirement: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['MissionRequirement']>;
    MissionReward: MissionReward;
    ModifyDelegationInput: ModifyDelegationInput;
    ModifyServiceDelegationInput: ModifyServiceDelegationInput;
    Multiplier: ResolverTypeWrapper<Omit<Multiplier, 'multiplierType'> & {
        multiplierType: ResolversTypes['MultiplierType'];
    }>;
    MultiplierType: ResolverTypeWrapper<Omit<MultiplierType, 'params'> & {
        params: ResolversTypes['MultiplierTypeParams'];
    }>;
    MultiplierTypeInput: MultiplierTypeInput;
    MultiplierTypeParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['MultiplierTypeParams']>;
    MultiplierTypeParamsCollection: ResolverTypeWrapper<MultiplierTypeParamsCollection>;
    MultiplierTypeParamsCreator: ResolverTypeWrapper<MultiplierTypeParamsCreator>;
    MultiplierTypeParamsNFTCount: ResolverTypeWrapper<MultiplierTypeParamsNftCount>;
    MultiplierTypeParamsStakeDuration: ResolverTypeWrapper<MultiplierTypeParamsStakeDuration>;
    Multipliers: ResolverTypeWrapper<Omit<Multipliers, 'collectionMultipliers' | 'countMultipliers' | 'creatorMultipliers' | 'durationMultipliers'> & {
        collectionMultipliers: Array<ResolversTypes['Multiplier']>;
        countMultipliers: Array<ResolversTypes['Multiplier']>;
        creatorMultipliers: Array<ResolversTypes['Multiplier']>;
        durationMultipliers: Array<ResolversTypes['Multiplier']>;
    }>;
    NectarMissionsPermissionInput: NectarMissionsPermissionInput;
    NectarStakingPermissionInput: NectarStakingPermissionInput;
    NewMissionCost: NewMissionCost;
    NewMissionData: NewMissionData;
    NewMissionPoolData: NewMissionPoolData;
    NftCreator: ResolverTypeWrapper<NftCreator>;
    NftCreatorInput: NftCreatorInput;
    Node: ResolverTypeWrapper<Node>;
    ID: ResolverTypeWrapper<Scalars['ID']['output']>;
    OutputHolding: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['OutputHolding']>;
    OutputHoldingTree: ResolverTypeWrapper<OutputHoldingTree>;
    PartialUserInfoInput: PartialUserInfoInput;
    ParticipateOnMissionData: ParticipateOnMissionData;
    PlatformData: ResolverTypeWrapper<PlatformData>;
    PlatformDataInput: PlatformDataInput;
    Profile: ResolverTypeWrapper<Profile>;
    ProfileDataConfig: ResolverTypeWrapper<ProfileDataConfig>;
    ProfileDataConfigInput: ProfileDataConfigInput;
    ProfileInfo: ResolverTypeWrapper<ProfileInfo>;
    ProfileInfoInput: ProfileInfoInput;
    Project: ResolverTypeWrapper<Omit<Project, 'services'> & {
        services: Array<ResolversTypes['Service']>;
    }>;
    Proof: ResolverTypeWrapper<Proof>;
    Pubkey: ResolverTypeWrapper<Scalars['Pubkey']['output']>;
    Query: ResolverTypeWrapper<{}>;
    RecallFromMissionData: RecallFromMissionData;
    Recipe: ResolverTypeWrapper<Recipe>;
    RecipeInputResource: RecipeInputResource;
    RecipeInputResources: RecipeInputResources;
    RecipeOutputResource: RecipeOutputResource;
    RecipeResources: RecipeResources;
    RemoveSocialsInput: RemoveSocialsInput;
    Resource: ResolverTypeWrapper<Omit<Resource, 'kind'> & {
        kind: ResolversTypes['ResourceKind'];
    }>;
    ResourceBalance: ResolverTypeWrapper<ResourceBalance>;
    ResourceCustody: ResolverTypeWrapper<ResourceCustody>;
    ResourceCustodyEnum: ResourceCustodyEnum;
    ResourceCustodyParams: ResolverTypeWrapper<ResourceCustodyParams>;
    ResourceKind: ResolverTypeWrapper<Omit<ResourceKind, 'params'> & {
        params?: Maybe<ResolversTypes['ResourceKindParams']>;
    }>;
    ResourceKindParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ResourceKindParams']>;
    ResourceKindParamsHplFungible: ResolverTypeWrapper<ResourceKindParamsHplFungible>;
    ResourceKindParamsHplNonFungible: ResolverTypeWrapper<ResourceKindParamsHplNonFungible>;
    ResourceKindParamsWrappedFungible: ResolverTypeWrapper<ResourceKindParamsWrappedFungible>;
    ResourceKindParamsWrappedMplCore: ResolverTypeWrapper<ResourceKindParamsWrappedMplCore>;
    ResourceManagerPermissionInput: ResourceManagerPermissionInput;
    ResourceRewardType: ResolverTypeWrapper<ResourceRewardType>;
    ResourceRewardTypeParams: ResolverTypeWrapper<ResourceRewardTypeParams>;
    ResourceStorage: ResolverTypeWrapper<ResourceStorage>;
    ResourceStorageEnum: ResourceStorageEnum;
    ResourceStorageParams: ResolverTypeWrapper<ResourceStorageParams>;
    Reward: ResolverTypeWrapper<Omit<Reward, 'rewardType'> & {
        rewardType?: Maybe<ResolversTypes['RewardType']>;
    }>;
    RewardKind: RewardKind;
    RewardPoolConfigApyInput: RewardPoolConfigApyInput;
    RewardType: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['RewardType']>;
    SendTransactionBundlesOptions: SendTransactionBundlesOptions;
    SendTransactionsOptions: SendTransactionsOptions;
    SerializableActions: ResolverTypeWrapper<SerializableActions>;
    SerializableActionsInput: SerializableActionsInput;
    Service: ResolverTypeWrapper<Omit<Service, 'params'> & {
        params?: Maybe<ResolversTypes['ServiceParams']>;
    }>;
    ServiceDelegation: ResolverTypeWrapper<ServiceDelegation>;
    ServiceDelegationBuzzGuild: ServiceDelegationBuzzGuild;
    ServiceDelegationCharacterManager: ServiceDelegationCharacterManager;
    ServiceDelegationHiveControl: ServiceDelegationHiveControl;
    ServiceDelegationInput: ServiceDelegationInput;
    ServiceDelegationNectarMissions: ServiceDelegationNectarMissions;
    ServiceDelegationNectarStaking: ServiceDelegationNectarStaking;
    ServiceDelegationResourceManager: ServiceDelegationResourceManager;
    ServiceParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['ServiceParams']>;
    ServiceParamsAssembler: ResolverTypeWrapper<ServiceParamsAssembler>;
    ServiceParamsAssetManager: ResolverTypeWrapper<ServiceParamsAssetManager>;
    ServiceParamsGuildKit: ResolverTypeWrapper<ServiceParamsGuildKit>;
    ServiceParamsMissions: ResolverTypeWrapper<ServiceParamsMissions>;
    ServiceParamsRaffles: ResolverTypeWrapper<ServiceParamsRaffles>;
    ServiceParamsStaking: ResolverTypeWrapper<ServiceParamsStaking>;
    SocialInfo: ResolverTypeWrapper<SocialInfo>;
    SourceKind: SourceKind;
    SplMultiplier: ResolverTypeWrapper<Omit<SplMultiplier, 'multiplierType'> & {
        multiplierType: ResolversTypes['SplMultiplierType'];
    }>;
    SplMultiplierInput: SplMultiplierInput;
    SplMultiplierType: ResolverTypeWrapper<Omit<SplMultiplierType, 'params'> & {
        params: ResolversTypes['SplMultiplierTypeParams'];
    }>;
    SplMultiplierTypeParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SplMultiplierTypeParams']>;
    SplMultiplierTypeParamsStakeAmount: ResolverTypeWrapper<SplMultiplierTypeParamsStakeAmount>;
    SplMultiplierTypeParamsStakeDuration: ResolverTypeWrapper<SplMultiplierTypeParamsStakeDuration>;
    SplRewardConfig: ResolverTypeWrapper<Omit<SplRewardConfig, 'params'> & {
        params?: Maybe<ResolversTypes['SplRewardConfigParams']>;
    }>;
    SplRewardConfigParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SplRewardConfigParams']>;
    SplRewardConfigParamsApy: ResolverTypeWrapper<SplRewardConfigParamsApy>;
    SplRewardConfigParamsNotSet: ResolverTypeWrapper<SplRewardConfigParamsNotSet>;
    SplRewardConfigParamsStakeWeight: ResolverTypeWrapper<SplRewardConfigParamsStakeWeight>;
    SplStakeWeightConfig: ResolverTypeWrapper<SplStakeWeightConfig>;
    SplStakingPool: ResolverTypeWrapper<Omit<SplStakingPool, 'multipliers' | 'rewardConfig'> & {
        multipliers: Array<ResolversTypes['SplMultiplier']>;
        rewardConfig: ResolversTypes['SplRewardConfig'];
    }>;
    Staker: ResolverTypeWrapper<Staker>;
    StakerClaimed: ResolverTypeWrapper<Omit<StakerClaimed, 'params'> & {
        params?: Maybe<ResolversTypes['StakerClaimedParams']>;
    }>;
    StakerClaimedParams: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['StakerClaimedParams']>;
    StakerClaimedParamsApy: ResolverTypeWrapper<StakerClaimedParamsApy>;
    StakerClaimedParamsNone: ResolverTypeWrapper<StakerClaimedParamsNone>;
    StakerClaimedParamsStakeWeight: ResolverTypeWrapper<StakerClaimedParamsStakeWeight>;
    StakingPool: ResolverTypeWrapper<StakingPool>;
    StakingRecipient: ResolverTypeWrapper<Omit<StakingRecipient, 'rewardsClaimed'> & {
        rewardsClaimed: ResolversTypes['StakerClaimed'];
    }>;
    StringTuple: ResolverTypeWrapper<Scalars['StringTuple']['output']>;
    TimeRequirement: ResolverTypeWrapper<TimeRequirement>;
    TimeRequirementParams: ResolverTypeWrapper<TimeRequirementParams>;
    Transaction: ResolverTypeWrapper<Transaction>;
    TransactionBundleResponse: ResolverTypeWrapper<TransactionBundleResponse>;
    TransactionBundlesOptions: TransactionBundlesOptions;
    TransactionResponse: ResolverTypeWrapper<TransactionResponse>;
    Transactions: ResolverTypeWrapper<Transactions>;
    TreeLeaf: TreeLeaf;
    TreeSetupConfig: TreeSetupConfig;
    TreeSetupResponse: ResolverTypeWrapper<TreeSetupResponse>;
    UpdateBadgeCriteriaInput: UpdateBadgeCriteriaInput;
    UpdateMissionData: UpdateMissionData;
    UpdateMissionInput: UpdateMissionInput;
    UpdateMissionPoolData: UpdateMissionPoolData;
    UpdateSplStakingPoolMetadataInput: UpdateSplStakingPoolMetadataInput;
    UpdateStakingPoolMetadataInput: UpdateStakingPoolMetadataInput;
    UpdateWalletInput: UpdateWalletInput;
    UsedByCustom: ResolverTypeWrapper<UsedByCustom>;
    UsedByEjected: ResolverTypeWrapper<UsedByEjected>;
    UsedByGuild: ResolverTypeWrapper<UsedByGuild>;
    UsedByGuildFilter: UsedByGuildFilter;
    UsedByMission: ResolverTypeWrapper<UsedByMission>;
    UsedByStaking: ResolverTypeWrapper<UsedByStaking>;
    User: ResolverTypeWrapper<User>;
    UserInfo: ResolverTypeWrapper<UserInfo>;
    UserInfoInput: UserInfoInput;
    VecMap: ResolverTypeWrapper<Scalars['VecMap']['output']>;
    VecMapGeneric: ResolverTypeWrapper<Scalars['VecMapGeneric']['output']>;
    Wallets: ResolverTypeWrapper<Wallets>;
    Wrapped: ResolverTypeWrapper<Wrapped>;
    XpRewardType: ResolverTypeWrapper<XpRewardType>;
}>;
export type ResolversParentTypes = ResolversObject<{
    Account: Account;
    AddMultiplierMetadataInput: AddMultiplierMetadataInput;
    AddRemoveRewardsFromRewardPoolActionInput: AddRemoveRewardsFromRewardPoolActionInput;
    AddSplMultiplierMetadataInput: AddSplMultiplierMetadataInput;
    AdvancedTreeConfig: AdvancedTreeConfig;
    Int: Scalars['Int']['output'];
    Assembled: Assembled;
    String: Scalars['String']['output'];
    AssemblerConfig: AssemblerConfig;
    AssemblerConfigInput: AssemblerConfigInput;
    AssetCriteria: AssetCriteria;
    AssetCriteriaFilter: AssetCriteriaFilter;
    AssetCriteriaInput: AssetCriteriaInput;
    AssociatedProgram: AssociatedProgram;
    AssociatedProgramInput: AssociatedProgramInput;
    AuthConfirmed: AuthConfirmed;
    AuthResponse: AuthResponse;
    BadgeCriteria: BadgeCriteria;
    BasicTreeConfig: BasicTreeConfig;
    BigInt: Scalars['BigInt']['output'];
    Bytes: Scalars['Bytes']['output'];
    Character: Omit<Character, 'source' | 'usedBy'> & {
        source: ResolversParentTypes['CharacterSource'];
        usedBy: ResolversParentTypes['CharacterUsedBy'];
    };
    CharacterConfig: ResolversUnionTypes<ResolversParentTypes>['CharacterConfig'];
    CharacterConfigAssembled: Omit<CharacterConfigAssembled, 'mintAs'> & {
        mintAs: ResolversParentTypes['MintAs'];
    };
    CharacterConfigInput: CharacterConfigInput;
    CharacterConfigWrapped: CharacterConfigWrapped;
    CharacterCooldown: CharacterCooldown;
    CharacterCooldownInput: CharacterCooldownInput;
    CharacterHistory: CharacterHistory;
    CharacterModel: Omit<CharacterModel, 'config'> & {
        config: ResolversParentTypes['CharacterConfig'];
    };
    CharacterSource: Omit<CharacterSource, 'params'> & {
        params: ResolversParentTypes['CharacterSourceParams'];
    };
    CharacterSourceFilter: CharacterSourceFilter;
    CharacterSourceParams: ResolversUnionTypes<ResolversParentTypes>['CharacterSourceParams'];
    CharacterSourceParamsFilter: CharacterSourceParamsFilter;
    Boolean: Scalars['Boolean']['output'];
    CharacterTrait: CharacterTrait;
    CharacterTraitInput: CharacterTraitInput;
    CharacterUsedBy: Omit<CharacterUsedBy, 'params'> & {
        params?: Maybe<ResolversParentTypes['CharacterUsedByParams']>;
    };
    CharacterUsedByFilter: CharacterUsedByFilter;
    CharacterUsedByParams: ResolversUnionTypes<ResolversParentTypes>['CharacterUsedByParams'];
    CharacterUsedByParamsFilter: CharacterUsedByParamsFilter;
    CharactersFilter: CharactersFilter;
    CivicInfo: CivicInfo;
    CivicInfoInput: CivicInfoInput;
    ClaimBadgeCriteriaInput: ClaimBadgeCriteriaInput;
    CompressedAccount: CompressedAccount;
    ControlledMerkleTrees: ControlledMerkleTrees;
    CreateAssemblerConfigTransactionResponse: CreateAssemblerConfigTransactionResponse;
    Float: Scalars['Float']['output'];
    CreateBadgeCriteriaInput: CreateBadgeCriteriaInput;
    CreateBeginCookingTransactionResponse: CreateBeginCookingTransactionResponse;
    CreateCharacterModelTransactionResponse: CreateCharacterModelTransactionResponse;
    CreateCreateHolderAccountTransactionResponse: CreateCreateHolderAccountTransactionResponse;
    CreateCreateMissionPoolTransactionResponse: CreateCreateMissionPoolTransactionResponse;
    CreateCreateMissionTransactionResponse: CreateCreateMissionTransactionResponse;
    CreateCreateNewResourceTreeTransactionResponse: CreateCreateNewResourceTreeTransactionResponse;
    CreateCreateProjectTransactionResponse: CreateCreateProjectTransactionResponse;
    CreateCreateSplStakingPoolTransactionResponse: CreateCreateSplStakingPoolTransactionResponse;
    CreateCreateStakingPoolTransactionResponse: CreateCreateStakingPoolTransactionResponse;
    CreateInitMultipliersTransactionResponse: CreateInitMultipliersTransactionResponse;
    CreateInitResourceTransactionResponse: CreateInitResourceTransactionResponse;
    CreateInitializeFaucetTransactionResponse: CreateInitializeFaucetTransactionResponse;
    CreateInitializeRecipeTransactionResponse: CreateInitializeRecipeTransactionResponse;
    CreateSplRewardPoolArgsInput: CreateSplRewardPoolArgsInput;
    CreateSplStakingPoolMetadataInput: CreateSplStakingPoolMetadataInput;
    CreateStakingPoolMetadataInput: CreateStakingPoolMetadataInput;
    CreateUpdateMissionPoolTransactionResponse: CreateUpdateMissionPoolTransactionResponse;
    CreateUpdateMissionTransactionResponse: CreateUpdateMissionTransactionResponse;
    CustomDataInput: CustomDataInput;
    DelegateAuthority: DelegateAuthority;
    DisrcriminatorFilter: DisrcriminatorFilter;
    EarnedRewards: EarnedRewards;
    EarnedRewardsFilter: EarnedRewardsFilter;
    Faucet: Faucet;
    Global: Global;
    GuildRole: GuildRole;
    GuildRoleFilter: GuildRoleFilter;
    Holding: Holding;
    ImportResourceInput: ImportResourceInput;
    ImportResourceInputCustodyInput: ImportResourceInputCustodyInput;
    Ingredient: Ingredient;
    IngredientsInput: IngredientsInput;
    InitResourceInput: InitResourceInput;
    InitStakingMultiplierMetadataInput: InitStakingMultiplierMetadataInput;
    JSON: Scalars['JSON']['output'];
    LockType: LockType;
    Meal: Meal;
    MealInput: MealInput;
    MintAs: Omit<MintAs, 'params'> & {
        params?: Maybe<ResolversParentTypes['MintAsParams']>;
    };
    MintAsInput: MintAsInput;
    MintAsMplBubblegumInput: MintAsMplBubblegumInput;
    MintAsParams: ResolversUnionTypes<ResolversParentTypes>['MintAsParams'];
    MintAsParamsMplBubblegum: MintAsParamsMplBubblegum;
    Mission: Omit<Mission, 'requirement' | 'rewards'> & {
        requirement: ResolversParentTypes['MissionRequirement'];
        rewards: Array<Maybe<ResolversParentTypes['Reward']>>;
    };
    MissionCost: MissionCost;
    MissionPool: MissionPool;
    MissionRequirement: ResolversUnionTypes<ResolversParentTypes>['MissionRequirement'];
    MissionReward: MissionReward;
    ModifyDelegationInput: ModifyDelegationInput;
    ModifyServiceDelegationInput: ModifyServiceDelegationInput;
    Multiplier: Omit<Multiplier, 'multiplierType'> & {
        multiplierType: ResolversParentTypes['MultiplierType'];
    };
    MultiplierType: Omit<MultiplierType, 'params'> & {
        params: ResolversParentTypes['MultiplierTypeParams'];
    };
    MultiplierTypeInput: MultiplierTypeInput;
    MultiplierTypeParams: ResolversUnionTypes<ResolversParentTypes>['MultiplierTypeParams'];
    MultiplierTypeParamsCollection: MultiplierTypeParamsCollection;
    MultiplierTypeParamsCreator: MultiplierTypeParamsCreator;
    MultiplierTypeParamsNFTCount: MultiplierTypeParamsNftCount;
    MultiplierTypeParamsStakeDuration: MultiplierTypeParamsStakeDuration;
    Multipliers: Omit<Multipliers, 'collectionMultipliers' | 'countMultipliers' | 'creatorMultipliers' | 'durationMultipliers'> & {
        collectionMultipliers: Array<ResolversParentTypes['Multiplier']>;
        countMultipliers: Array<ResolversParentTypes['Multiplier']>;
        creatorMultipliers: Array<ResolversParentTypes['Multiplier']>;
        durationMultipliers: Array<ResolversParentTypes['Multiplier']>;
    };
    NewMissionCost: NewMissionCost;
    NewMissionData: NewMissionData;
    NewMissionPoolData: NewMissionPoolData;
    NftCreator: NftCreator;
    NftCreatorInput: NftCreatorInput;
    Node: Node;
    ID: Scalars['ID']['output'];
    OutputHolding: ResolversUnionTypes<ResolversParentTypes>['OutputHolding'];
    OutputHoldingTree: OutputHoldingTree;
    PartialUserInfoInput: PartialUserInfoInput;
    ParticipateOnMissionData: ParticipateOnMissionData;
    PlatformData: PlatformData;
    PlatformDataInput: PlatformDataInput;
    Profile: Profile;
    ProfileDataConfig: ProfileDataConfig;
    ProfileDataConfigInput: ProfileDataConfigInput;
    ProfileInfo: ProfileInfo;
    ProfileInfoInput: ProfileInfoInput;
    Project: Omit<Project, 'services'> & {
        services: Array<ResolversParentTypes['Service']>;
    };
    Proof: Proof;
    Pubkey: Scalars['Pubkey']['output'];
    Query: {};
    RecallFromMissionData: RecallFromMissionData;
    Recipe: Recipe;
    RecipeInputResource: RecipeInputResource;
    RecipeInputResources: RecipeInputResources;
    RecipeOutputResource: RecipeOutputResource;
    RecipeResources: RecipeResources;
    Resource: Omit<Resource, 'kind'> & {
        kind: ResolversParentTypes['ResourceKind'];
    };
    ResourceBalance: ResourceBalance;
    ResourceCustody: ResourceCustody;
    ResourceCustodyParams: ResourceCustodyParams;
    ResourceKind: Omit<ResourceKind, 'params'> & {
        params?: Maybe<ResolversParentTypes['ResourceKindParams']>;
    };
    ResourceKindParams: ResolversUnionTypes<ResolversParentTypes>['ResourceKindParams'];
    ResourceKindParamsHplFungible: ResourceKindParamsHplFungible;
    ResourceKindParamsHplNonFungible: ResourceKindParamsHplNonFungible;
    ResourceKindParamsWrappedFungible: ResourceKindParamsWrappedFungible;
    ResourceKindParamsWrappedMplCore: ResourceKindParamsWrappedMplCore;
    ResourceRewardType: ResourceRewardType;
    ResourceRewardTypeParams: ResourceRewardTypeParams;
    ResourceStorage: ResourceStorage;
    ResourceStorageParams: ResourceStorageParams;
    Reward: Omit<Reward, 'rewardType'> & {
        rewardType?: Maybe<ResolversParentTypes['RewardType']>;
    };
    RewardPoolConfigApyInput: RewardPoolConfigApyInput;
    RewardType: ResolversUnionTypes<ResolversParentTypes>['RewardType'];
    SendTransactionBundlesOptions: SendTransactionBundlesOptions;
    SendTransactionsOptions: SendTransactionsOptions;
    SerializableActions: SerializableActions;
    SerializableActionsInput: SerializableActionsInput;
    Service: Omit<Service, 'params'> & {
        params?: Maybe<ResolversParentTypes['ServiceParams']>;
    };
    ServiceDelegation: ServiceDelegation;
    ServiceDelegationBuzzGuild: ServiceDelegationBuzzGuild;
    ServiceDelegationCharacterManager: ServiceDelegationCharacterManager;
    ServiceDelegationHiveControl: ServiceDelegationHiveControl;
    ServiceDelegationInput: ServiceDelegationInput;
    ServiceDelegationNectarMissions: ServiceDelegationNectarMissions;
    ServiceDelegationNectarStaking: ServiceDelegationNectarStaking;
    ServiceDelegationResourceManager: ServiceDelegationResourceManager;
    ServiceParams: ResolversUnionTypes<ResolversParentTypes>['ServiceParams'];
    ServiceParamsAssembler: ServiceParamsAssembler;
    ServiceParamsAssetManager: ServiceParamsAssetManager;
    ServiceParamsGuildKit: ServiceParamsGuildKit;
    ServiceParamsMissions: ServiceParamsMissions;
    ServiceParamsRaffles: ServiceParamsRaffles;
    ServiceParamsStaking: ServiceParamsStaking;
    SocialInfo: SocialInfo;
    SplMultiplier: Omit<SplMultiplier, 'multiplierType'> & {
        multiplierType: ResolversParentTypes['SplMultiplierType'];
    };
    SplMultiplierInput: SplMultiplierInput;
    SplMultiplierType: Omit<SplMultiplierType, 'params'> & {
        params: ResolversParentTypes['SplMultiplierTypeParams'];
    };
    SplMultiplierTypeParams: ResolversUnionTypes<ResolversParentTypes>['SplMultiplierTypeParams'];
    SplMultiplierTypeParamsStakeAmount: SplMultiplierTypeParamsStakeAmount;
    SplMultiplierTypeParamsStakeDuration: SplMultiplierTypeParamsStakeDuration;
    SplRewardConfig: Omit<SplRewardConfig, 'params'> & {
        params?: Maybe<ResolversParentTypes['SplRewardConfigParams']>;
    };
    SplRewardConfigParams: ResolversUnionTypes<ResolversParentTypes>['SplRewardConfigParams'];
    SplRewardConfigParamsApy: SplRewardConfigParamsApy;
    SplRewardConfigParamsNotSet: SplRewardConfigParamsNotSet;
    SplRewardConfigParamsStakeWeight: SplRewardConfigParamsStakeWeight;
    SplStakeWeightConfig: SplStakeWeightConfig;
    SplStakingPool: Omit<SplStakingPool, 'multipliers' | 'rewardConfig'> & {
        multipliers: Array<ResolversParentTypes['SplMultiplier']>;
        rewardConfig: ResolversParentTypes['SplRewardConfig'];
    };
    Staker: Staker;
    StakerClaimed: Omit<StakerClaimed, 'params'> & {
        params?: Maybe<ResolversParentTypes['StakerClaimedParams']>;
    };
    StakerClaimedParams: ResolversUnionTypes<ResolversParentTypes>['StakerClaimedParams'];
    StakerClaimedParamsApy: StakerClaimedParamsApy;
    StakerClaimedParamsNone: StakerClaimedParamsNone;
    StakerClaimedParamsStakeWeight: StakerClaimedParamsStakeWeight;
    StakingPool: StakingPool;
    StakingRecipient: Omit<StakingRecipient, 'rewardsClaimed'> & {
        rewardsClaimed: ResolversParentTypes['StakerClaimed'];
    };
    StringTuple: Scalars['StringTuple']['output'];
    TimeRequirement: TimeRequirement;
    TimeRequirementParams: TimeRequirementParams;
    Transaction: Transaction;
    TransactionBundleResponse: TransactionBundleResponse;
    TransactionBundlesOptions: TransactionBundlesOptions;
    TransactionResponse: TransactionResponse;
    Transactions: Transactions;
    TreeLeaf: TreeLeaf;
    TreeSetupConfig: TreeSetupConfig;
    TreeSetupResponse: TreeSetupResponse;
    UpdateBadgeCriteriaInput: UpdateBadgeCriteriaInput;
    UpdateMissionData: UpdateMissionData;
    UpdateMissionInput: UpdateMissionInput;
    UpdateMissionPoolData: UpdateMissionPoolData;
    UpdateSplStakingPoolMetadataInput: UpdateSplStakingPoolMetadataInput;
    UpdateStakingPoolMetadataInput: UpdateStakingPoolMetadataInput;
    UpdateWalletInput: UpdateWalletInput;
    UsedByCustom: UsedByCustom;
    UsedByEjected: UsedByEjected;
    UsedByGuild: UsedByGuild;
    UsedByGuildFilter: UsedByGuildFilter;
    UsedByMission: UsedByMission;
    UsedByStaking: UsedByStaking;
    User: User;
    UserInfo: UserInfo;
    UserInfoInput: UserInfoInput;
    VecMap: Scalars['VecMap']['output'];
    VecMapGeneric: Scalars['VecMapGeneric']['output'];
    Wallets: Wallets;
    Wrapped: Wrapped;
    XpRewardType: XpRewardType;
}>;
export type AccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    discriminator?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    parsed_data?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
    program_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type AssembledResolvers<ContextType = any, ParentType extends ResolversParentTypes['Assembled'] = ResolversParentTypes['Assembled']> = ResolversObject<{
    assemblerConfig?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    attributes?: Resolver<Maybe<ResolversTypes['VecMap']>, ParentType, ContextType>;
    hash?: Resolver<Maybe<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    mint?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type AssemblerConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssemblerConfig'] = ResolversParentTypes['AssemblerConfig']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    discriminator?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    merkle_trees?: Resolver<Maybe<ResolversTypes['ControlledMerkleTrees']>, ParentType, ContextType>;
    order?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
    program_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    ticker?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type AssetCriteriaResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssetCriteria'] = ResolversParentTypes['AssetCriteria']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['AssetCriteriaKind'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type AssociatedProgramResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssociatedProgram'] = ResolversParentTypes['AssociatedProgram']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    trustedActions?: Resolver<Array<ResolversTypes['SerializableActions']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type AuthConfirmedResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthConfirmed'] = ResolversParentTypes['AuthConfirmed']> = ResolversObject<{
    accessToken?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    user?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type AuthResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthResponse'] = ResolversParentTypes['AuthResponse']> = ResolversObject<{
    message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tx?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type BadgeCriteriaResolvers<ContextType = any, ParentType extends ResolversParentTypes['BadgeCriteria'] = ResolversParentTypes['BadgeCriteria']> = ResolversObject<{
    condition?: Resolver<ResolversTypes['BadgesCondition'], ParentType, ContextType>;
    endTime?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    index?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    startTime?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
    name: 'BigInt';
}
export interface BytesScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Bytes'], any> {
    name: 'Bytes';
}
export type CharacterResolvers<ContextType = any, ParentType extends ResolversParentTypes['Character'] = ResolversParentTypes['Character']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    asset?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
    cooldown?: Resolver<ResolversTypes['CharacterCooldown'], ParentType, ContextType>;
    equipments?: Resolver<ResolversTypes['VecMap'], ParentType, ContextType>;
    leaf_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    owner?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    proof?: Resolver<Maybe<ResolversTypes['Proof']>, ParentType, ContextType>;
    source?: Resolver<ResolversTypes['CharacterSource'], ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    usedBy?: Resolver<ResolversTypes['CharacterUsedBy'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterConfig'] = ResolversParentTypes['CharacterConfig']> = ResolversObject<{
    __resolveType: TypeResolveFn<'CharacterConfigAssembled' | 'CharacterConfigWrapped', ParentType, ContextType>;
}>;
export type CharacterConfigAssembledResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterConfigAssembled'] = ResolversParentTypes['CharacterConfigAssembled']> = ResolversObject<{
    assemblerConfig?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    collectionName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    creators?: Resolver<Array<ResolversTypes['NftCreator']>, ParentType, ContextType>;
    description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    mintAs?: Resolver<ResolversTypes['MintAs'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    sellerFeeBasisPoints?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterConfigWrappedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterConfigWrapped'] = ResolversParentTypes['CharacterConfigWrapped']> = ResolversObject<{
    criterias?: Resolver<Array<ResolversTypes['AssetCriteria']>, ParentType, ContextType>;
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterCooldownResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterCooldown'] = ResolversParentTypes['CharacterCooldown']> = ResolversObject<{
    ejection?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterHistory'] = ResolversParentTypes['CharacterHistory']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    event?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    event_data?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    time?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterModelResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterModel'] = ResolversParentTypes['CharacterModel']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    attributes?: Resolver<ResolversTypes['VecMapGeneric'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    config?: Resolver<ResolversTypes['CharacterConfig'], ParentType, ContextType>;
    cooldown?: Resolver<ResolversTypes['CharacterCooldown'], ParentType, ContextType>;
    discriminator?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    equipableCriteria?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    merkle_trees?: Resolver<ResolversTypes['ControlledMerkleTrees'], ParentType, ContextType>;
    program_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterSourceResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterSource'] = ResolversParentTypes['CharacterSource']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['CharacterSourceKind'], ParentType, ContextType>;
    params?: Resolver<ResolversTypes['CharacterSourceParams'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterSourceParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterSourceParams'] = ResolversParentTypes['CharacterSourceParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'Assembled' | 'Wrapped', ParentType, ContextType>;
}>;
export type CharacterTraitResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterTrait'] = ResolversParentTypes['CharacterTrait']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    layer?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    leaf_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    proof?: Resolver<Maybe<ResolversTypes['Proof']>, ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    uri?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterUsedByResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterUsedBy'] = ResolversParentTypes['CharacterUsedBy']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['CharacterUsedByParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CharacterUsedByParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CharacterUsedByParams'] = ResolversParentTypes['CharacterUsedByParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'UsedByCustom' | 'UsedByEjected' | 'UsedByGuild' | 'UsedByMission' | 'UsedByStaking', ParentType, ContextType>;
}>;
export type CivicInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['CivicInfo'] = ResolversParentTypes['CivicInfo']> = ResolversObject<{
    expiry?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    gatekeeperNetwork?: Resolver<ResolversTypes['CivicGateway'], ParentType, ContextType>;
    walletIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CompressedAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['CompressedAccount'] = ResolversParentTypes['CompressedAccount']> = ResolversObject<{
    leaf_idx?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    parsed_data?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
    raw_data?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    schema_validated?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    tree_id?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ControlledMerkleTreesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ControlledMerkleTrees'] = ResolversParentTypes['ControlledMerkleTrees']> = ResolversObject<{
    active?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    merkle_trees?: Resolver<Array<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    schema?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateAssemblerConfigTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateAssemblerConfigTransactionResponse'] = ResolversParentTypes['CreateAssemblerConfigTransactionResponse']> = ResolversObject<{
    assemblerConfig?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    cost?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    maxTreeCapacity?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    proofBytes?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    space?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    treeAddress?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateBeginCookingTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateBeginCookingTransactionResponse'] = ResolversParentTypes['CreateBeginCookingTransactionResponse']> = ResolversObject<{
    cooking?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    transaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCharacterModelTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCharacterModelTransactionResponse'] = ResolversParentTypes['CreateCharacterModelTransactionResponse']> = ResolversObject<{
    characterModel?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateHolderAccountTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateHolderAccountTransactionResponse'] = ResolversParentTypes['CreateCreateHolderAccountTransactionResponse']> = ResolversObject<{
    holderAccount?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateMissionPoolTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateMissionPoolTransactionResponse'] = ResolversParentTypes['CreateCreateMissionPoolTransactionResponse']> = ResolversObject<{
    missionPoolAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateMissionTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateMissionTransactionResponse'] = ResolversParentTypes['CreateCreateMissionTransactionResponse']> = ResolversObject<{
    missionAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateNewResourceTreeTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateNewResourceTreeTransactionResponse'] = ResolversParentTypes['CreateCreateNewResourceTreeTransactionResponse']> = ResolversObject<{
    tree?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateProjectTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateProjectTransactionResponse'] = ResolversParentTypes['CreateCreateProjectTransactionResponse']> = ResolversObject<{
    project?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateSplStakingPoolTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateSplStakingPoolTransactionResponse'] = ResolversParentTypes['CreateCreateSplStakingPoolTransactionResponse']> = ResolversObject<{
    splStakingPoolAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateCreateStakingPoolTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCreateStakingPoolTransactionResponse'] = ResolversParentTypes['CreateCreateStakingPoolTransactionResponse']> = ResolversObject<{
    multipliersAddress?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;
    stakingPoolAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    transactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateInitMultipliersTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateInitMultipliersTransactionResponse'] = ResolversParentTypes['CreateInitMultipliersTransactionResponse']> = ResolversObject<{
    multipliersAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateInitResourceTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateInitResourceTransactionResponse'] = ResolversParentTypes['CreateInitResourceTransactionResponse']> = ResolversObject<{
    resource?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateInitializeFaucetTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateInitializeFaucetTransactionResponse'] = ResolversParentTypes['CreateInitializeFaucetTransactionResponse']> = ResolversObject<{
    faucet?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateInitializeRecipeTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateInitializeRecipeTransactionResponse'] = ResolversParentTypes['CreateInitializeRecipeTransactionResponse']> = ResolversObject<{
    recipe?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    transactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateUpdateMissionPoolTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUpdateMissionPoolTransactionResponse'] = ResolversParentTypes['CreateUpdateMissionPoolTransactionResponse']> = ResolversObject<{
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type CreateUpdateMissionTransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUpdateMissionTransactionResponse'] = ResolversParentTypes['CreateUpdateMissionTransactionResponse']> = ResolversObject<{
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type DelegateAuthorityResolvers<ContextType = any, ParentType extends ResolversParentTypes['DelegateAuthority'] = ResolversParentTypes['DelegateAuthority']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    authority?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    delegations?: Resolver<Array<ResolversTypes['ServiceDelegation']>, ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type EarnedRewardsResolvers<ContextType = any, ParentType extends ResolversParentTypes['EarnedRewards'] = ResolversParentTypes['EarnedRewards']> = ResolversObject<{
    collected?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    delta?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    rewardIdx?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type FaucetResolvers<ContextType = any, ParentType extends ResolversParentTypes['Faucet'] = ResolversParentTypes['Faucet']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    amount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    lastClaimed?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    repeatInterval?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    resource?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type GlobalResolvers<ContextType = any, ParentType extends ResolversParentTypes['Global'] = ResolversParentTypes['Global']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    config?: Resolver<ResolversTypes['VecMap'], ParentType, ContextType>;
    totalUsers?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    userTrees?: Resolver<ResolversTypes['ControlledMerkleTrees'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type GuildRoleResolvers<ContextType = any, ParentType extends ResolversParentTypes['GuildRole'] = ResolversParentTypes['GuildRole']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type HoldingResolvers<ContextType = any, ParentType extends ResolversParentTypes['Holding'] = ResolversParentTypes['Holding']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    balance?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    characteristics?: Resolver<Maybe<ResolversTypes['VecMap']>, ParentType, ContextType>;
    holder?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    leaf_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    proof?: Resolver<Maybe<ResolversTypes['Proof']>, ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type IngredientResolvers<ContextType = any, ParentType extends ResolversParentTypes['Ingredient'] = ResolversParentTypes['Ingredient']> = ResolversObject<{
    amount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    resourceAddress?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
    name: 'JSON';
}
export type LockTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['LockType'] = ResolversParentTypes['LockType']> = ResolversObject<{
    kind?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MealResolvers<ContextType = any, ParentType extends ResolversParentTypes['Meal'] = ResolversParentTypes['Meal']> = ResolversObject<{
    amount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    resourceAddress?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MintAsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MintAs'] = ResolversParentTypes['MintAs']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['MintAsKind'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['MintAsParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MintAsParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MintAsParams'] = ResolversParentTypes['MintAsParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'MintAsParamsMplBubblegum', ParentType, ContextType>;
}>;
export type MintAsParamsMplBubblegumResolvers<ContextType = any, ParentType extends ResolversParentTypes['MintAsParamsMplBubblegum'] = ResolversParentTypes['MintAsParamsMplBubblegum']> = ResolversObject<{
    merkleTree?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mission'] = ResolversParentTypes['Mission']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    cost?: Resolver<ResolversTypes['MissionCost'], ParentType, ContextType>;
    discriminator?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    minXp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    missionPool?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    program_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    requirement?: Resolver<ResolversTypes['MissionRequirement'], ParentType, ContextType>;
    rewards?: Resolver<Array<Maybe<ResolversTypes['Reward']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MissionCostResolvers<ContextType = any, ParentType extends ResolversParentTypes['MissionCost'] = ResolversParentTypes['MissionCost']> = ResolversObject<{
    amount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    resource_address?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MissionPoolResolvers<ContextType = any, ParentType extends ResolversParentTypes['MissionPool'] = ResolversParentTypes['MissionPool']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    characterModels?: Resolver<Array<Maybe<ResolversTypes['Pubkey']>>, ParentType, ContextType>;
    discriminator?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    factionsMerkleRoot?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    guildKits?: Resolver<Array<Maybe<ResolversTypes['Int']>>, ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    program_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    randomizerRound?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MissionRequirementResolvers<ContextType = any, ParentType extends ResolversParentTypes['MissionRequirement'] = ResolversParentTypes['MissionRequirement']> = ResolversObject<{
    __resolveType: TypeResolveFn<'TimeRequirement', ParentType, ContextType>;
}>;
export type MultiplierResolvers<ContextType = any, ParentType extends ResolversParentTypes['Multiplier'] = ResolversParentTypes['Multiplier']> = ResolversObject<{
    multiplierType?: Resolver<ResolversTypes['MultiplierType'], ParentType, ContextType>;
    value?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MultiplierTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiplierType'] = ResolversParentTypes['MultiplierType']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<ResolversTypes['MultiplierTypeParams'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MultiplierTypeParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiplierTypeParams'] = ResolversParentTypes['MultiplierTypeParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'MultiplierTypeParamsCollection' | 'MultiplierTypeParamsCreator' | 'MultiplierTypeParamsNFTCount' | 'MultiplierTypeParamsStakeDuration', ParentType, ContextType>;
}>;
export type MultiplierTypeParamsCollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiplierTypeParamsCollection'] = ResolversParentTypes['MultiplierTypeParamsCollection']> = ResolversObject<{
    collection?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MultiplierTypeParamsCreatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiplierTypeParamsCreator'] = ResolversParentTypes['MultiplierTypeParamsCreator']> = ResolversObject<{
    creator?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MultiplierTypeParamsNftCountResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiplierTypeParamsNFTCount'] = ResolversParentTypes['MultiplierTypeParamsNFTCount']> = ResolversObject<{
    minCount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MultiplierTypeParamsStakeDurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MultiplierTypeParamsStakeDuration'] = ResolversParentTypes['MultiplierTypeParamsStakeDuration']> = ResolversObject<{
    minDuration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type MultipliersResolvers<ContextType = any, ParentType extends ResolversParentTypes['Multipliers'] = ResolversParentTypes['Multipliers']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    collectionMultipliers?: Resolver<Array<ResolversTypes['Multiplier']>, ParentType, ContextType>;
    countMultipliers?: Resolver<Array<ResolversTypes['Multiplier']>, ParentType, ContextType>;
    creatorMultipliers?: Resolver<Array<ResolversTypes['Multiplier']>, ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    durationMultipliers?: Resolver<Array<ResolversTypes['Multiplier']>, ParentType, ContextType>;
    stakingPool?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type NftCreatorResolvers<ContextType = any, ParentType extends ResolversParentTypes['NftCreator'] = ResolversParentTypes['NftCreator']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    share?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = ResolversObject<{
    hash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
    leaf_idx?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    level?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    node_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    seq?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    tree?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type OutputHoldingResolvers<ContextType = any, ParentType extends ResolversParentTypes['OutputHolding'] = ResolversParentTypes['OutputHolding']> = ResolversObject<{
    __resolveType: TypeResolveFn<'Holding' | 'OutputHoldingTree', ParentType, ContextType>;
}>;
export type OutputHoldingTreeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OutputHoldingTree'] = ResolversParentTypes['OutputHoldingTree']> = ResolversObject<{
    tree?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type PlatformDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['PlatformData'] = ResolversParentTypes['PlatformData']> = ResolversObject<{
    achievements?: Resolver<Array<ResolversTypes['Int']>, ParentType, ContextType>;
    custom?: Resolver<ResolversTypes['VecMap'], ParentType, ContextType>;
    xp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ProfileResolvers<ContextType = any, ParentType extends ResolversParentTypes['Profile'] = ResolversParentTypes['Profile']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    customData?: Resolver<ResolversTypes['VecMap'], ParentType, ContextType>;
    identity?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    info?: Resolver<ResolversTypes['ProfileInfo'], ParentType, ContextType>;
    leaf_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    platformData?: Resolver<ResolversTypes['PlatformData'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    proof?: Resolver<Maybe<ResolversTypes['Proof']>, ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
    userId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ProfileDataConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProfileDataConfig'] = ResolversParentTypes['ProfileDataConfig']> = ResolversObject<{
    achievements?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    customDataFields?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ProfileInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProfileInfo'] = ResolversParentTypes['ProfileInfo']> = ResolversObject<{
    bio?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    pfp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ProjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['Project'] = ResolversParentTypes['Project']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    associatedPrograms?: Resolver<Array<ResolversTypes['AssociatedProgram']>, ParentType, ContextType>;
    authority?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    badgeCriteria?: Resolver<Maybe<Array<ResolversTypes['BadgeCriteria']>>, ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    driver?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    key?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    profileDataConfig?: Resolver<ResolversTypes['ProfileDataConfig'], ParentType, ContextType>;
    profileTrees?: Resolver<ResolversTypes['ControlledMerkleTrees'], ParentType, ContextType>;
    services?: Resolver<Array<ResolversTypes['Service']>, ParentType, ContextType>;
    subsidyFees?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ProofResolvers<ContextType = any, ParentType extends ResolversParentTypes['Proof'] = ResolversParentTypes['Proof']> = ResolversObject<{
    canopy_depth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    leaf?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    leaf_index?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    maxDepth?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    node_index?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    proof?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;
    root?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export interface PubkeyScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Pubkey'], any> {
    name: 'Pubkey';
}
export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
    account?: Resolver<Array<ResolversTypes['Account']>, ParentType, ContextType, RequireFields<QueryAccountArgs, 'programId'>>;
    assemblerConfig?: Resolver<Array<ResolversTypes['AssemblerConfig']>, ParentType, ContextType, Partial<QueryAssemblerConfigArgs>>;
    authConfirm?: Resolver<ResolversTypes['AuthConfirmed'], ParentType, ContextType, RequireFields<QueryAuthConfirmArgs, 'signature' | 'wallet'>>;
    authRequest?: Resolver<ResolversTypes['AuthResponse'], ParentType, ContextType, RequireFields<QueryAuthRequestArgs, 'wallet'>>;
    character?: Resolver<Array<ResolversTypes['Character']>, ParentType, ContextType, Partial<QueryCharacterArgs>>;
    characterHistory?: Resolver<Array<ResolversTypes['CharacterHistory']>, ParentType, ContextType, RequireFields<QueryCharacterHistoryArgs, 'addresses'>>;
    characterModel?: Resolver<Array<ResolversTypes['CharacterModel']>, ParentType, ContextType, Partial<QueryCharacterModelArgs>>;
    characterTrait?: Resolver<Array<ResolversTypes['CharacterTrait']>, ParentType, ContextType, Partial<QueryCharacterTraitArgs>>;
    compressedAccount?: Resolver<Array<ResolversTypes['CompressedAccount']>, ParentType, ContextType, RequireFields<QueryCompressedAccountArgs, 'addresses'>>;
    createAddCharacterTraitsTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateAddCharacterTraitsTransactionsArgs, 'assemblerConfig' | 'authority' | 'traits'>>;
    createAddIngredientsTransaction?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateAddIngredientsTransactionArgs, 'authority' | 'ingredients' | 'recipe'>>;
    createAddMultiplierTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateAddMultiplierTransactionArgs, 'authority' | 'metadata' | 'multiplier' | 'project'>>;
    createAddRemoveRewardsFromRewardPoolTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateAddRemoveRewardsFromRewardPoolTransactionArgs, 'action' | 'authority' | 'project' | 'rewardTokenMint' | 'splStakingPool'>>;
    createAddRemoveSplMultipliersTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateAddRemoveSplMultipliersTransactionArgs, 'authority' | 'project' | 'splStakingPool'>>;
    createAssembleCharacterTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateAssembleCharacterTransactionArgs, 'assemblerConfig' | 'authority' | 'characterModel' | 'owner' | 'project'>>;
    createBurnAssetsTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateBurnAssetsTransactionsArgs, 'addresses'>>;
    createBurnResourceTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateBurnResourceTransactionArgs, 'amount' | 'authority' | 'resource'>>;
    createChangeProjectDriverTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateChangeProjectDriverTransactionArgs, 'authority' | 'driver' | 'project'>>;
    createClaimBadgeCriteriaTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateClaimBadgeCriteriaTransactionArgs, 'args'>>;
    createClaimFaucetTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateClaimFaucetTransactionArgs, 'faucet' | 'owner'>>;
    createClaimSplRewardsTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateClaimSplRewardsTransactionArgs, 'payer' | 'project' | 'splStakingPool' | 'staker' | 'stakingReciept'>>;
    createClaimStakingRewardsTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateClaimStakingRewardsTransactionsArgs, 'characterAddresses' | 'characterModel'>>;
    createCreateAssemblerConfigTransaction?: Resolver<ResolversTypes['CreateAssemblerConfigTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateAssemblerConfigTransactionArgs, 'authority' | 'project' | 'ticker'>>;
    createCreateCharacterModelTransaction?: Resolver<ResolversTypes['CreateCharacterModelTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateCharacterModelTransactionArgs, 'authority' | 'config' | 'project'>>;
    createCreateCharactersTreeTransaction?: Resolver<ResolversTypes['TreeSetupResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateCharactersTreeTransactionArgs, 'authority' | 'characterModel' | 'project' | 'treeConfig'>>;
    createCreateDelegateAuthorityTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateCreateDelegateAuthorityTransactionArgs, 'authority' | 'delegate' | 'project' | 'serviceDelegations'>>;
    createCreateMissionPoolTransaction?: Resolver<ResolversTypes['CreateCreateMissionPoolTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateMissionPoolTransactionArgs, 'data'>>;
    createCreateMissionTransaction?: Resolver<ResolversTypes['CreateCreateMissionTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateMissionTransactionArgs, 'data'>>;
    createCreateNewResourceTransaction?: Resolver<ResolversTypes['CreateInitResourceTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateNewResourceTransactionArgs, 'authority' | 'params' | 'project'>>;
    createCreateNewResourceTreeTransaction?: Resolver<ResolversTypes['TreeSetupResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateNewResourceTreeTransactionArgs, 'authority' | 'project' | 'resource' | 'treeConfig'>>;
    createCreateNewSplStakingPoolTreeTransaction?: Resolver<ResolversTypes['TreeSetupResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateNewSplStakingPoolTreeTransactionArgs, 'authority' | 'project' | 'splStakingPool' | 'treeConfig'>>;
    createCreateProfilesTreeTransaction?: Resolver<ResolversTypes['TreeSetupResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateProfilesTreeTransactionArgs, 'payer' | 'project' | 'treeConfig'>>;
    createCreateProjectTransaction?: Resolver<ResolversTypes['CreateCreateProjectTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateProjectTransactionArgs, 'authority' | 'name'>>;
    createCreateSplStakingPoolTransaction?: Resolver<ResolversTypes['CreateCreateSplStakingPoolTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateSplStakingPoolTransactionArgs, 'authority' | 'metadata' | 'project' | 'stakeTokenMint'>>;
    createCreateStakingPoolTransaction?: Resolver<ResolversTypes['CreateCreateStakingPoolTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateCreateStakingPoolTransactionArgs, 'authority' | 'metadata' | 'project' | 'resource'>>;
    createCreateUnwrapHoldingTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateCreateUnwrapHoldingTransactionArgs, 'amount' | 'authority' | 'resource'>>;
    createCreateWrapHoldingTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateCreateWrapHoldingTransactionArgs, 'amount' | 'authority' | 'resource'>>;
    createDismountResourceOnCharacterTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateDismountResourceOnCharacterTransactionArgs, 'amount' | 'characterAddress' | 'characterModel' | 'owner' | 'resource'>>;
    createEquipResourceOnCharacterTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateEquipResourceOnCharacterTransactionArgs, 'amount' | 'characterAddress' | 'characterModel' | 'owner' | 'resource'>>;
    createExportFungibleResourceTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateExportFungibleResourceTransactionArgs, 'authority' | 'resource'>>;
    createImportFungibleResourceTransaction?: Resolver<ResolversTypes['CreateInitResourceTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateImportFungibleResourceTransactionArgs, 'params'>>;
    createInitCookingProcessTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateInitCookingProcessTransactionsArgs, 'authority' | 'recipe'>>;
    createInitMultipliersTransaction?: Resolver<ResolversTypes['CreateInitMultipliersTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateInitMultipliersTransactionArgs, 'authority' | 'decimals' | 'multipliers' | 'project' | 'stakingPool'>>;
    createInitializeBadgeCriteriaTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateInitializeBadgeCriteriaTransactionArgs, 'args'>>;
    createInitializeFaucetTransaction?: Resolver<ResolversTypes['CreateInitializeFaucetTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateInitializeFaucetTransactionArgs, 'amount' | 'authority' | 'repeatInterval' | 'resource'>>;
    createInitializeRecipeTransaction?: Resolver<ResolversTypes['CreateInitializeRecipeTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateInitializeRecipeTransactionArgs, 'authority' | 'ingredients' | 'meal' | 'project' | 'xp'>>;
    createMintResourceTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateMintResourceTransactionArgs, 'amount' | 'authority' | 'owner' | 'resource'>>;
    createModifyDelegationTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateModifyDelegationTransactionArgs, 'authority' | 'delegate' | 'modifyDelegation' | 'project'>>;
    createNewProfileTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateNewProfileTransactionArgs, 'payer' | 'project'>>;
    createNewUserBulkTransaction?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateNewUserBulkTransactionArgs, 'info' | 'payer' | 'wallet'>>;
    createNewUserTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateNewUserTransactionArgs, 'wallet'>>;
    createNewUserWithProfileTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateNewUserWithProfileTransactionArgs, 'project' | 'userInfo' | 'wallet'>>;
    createPopulateCharacterTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreatePopulateCharacterTransactionArgs, 'characterModel' | 'mint' | 'owner' | 'payer' | 'project' | 'updateAuthority'>>;
    createRecallCharactersTransaction?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateRecallCharactersTransactionArgs, 'data'>>;
    createRemoveCharacterTraitsTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateRemoveCharacterTraitsTransactionsArgs, 'assemblerConfig' | 'authority' | 'traitsAddresses'>>;
    createRemoveIngredientsTransaction?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateRemoveIngredientsTransactionArgs, 'authority' | 'ingredients' | 'recipe'>>;
    createSendCharactersOnMissionTransaction?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateSendCharactersOnMissionTransactionArgs, 'data'>>;
    createSplRewardPoolTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateSplRewardPoolTransactionArgs, 'authority' | 'project' | 'rewardConfig' | 'rewardTokenMint' | 'splStakingPool'>>;
    createStakeCharactersTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateStakeCharactersTransactionsArgs, 'characterAddresses' | 'characterModel' | 'project' | 'stakingPool'>>;
    createStakeSplTokensTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateStakeSplTokensTransactionArgs, 'amount' | 'lockPeriodSecs' | 'payer' | 'project' | 'splStakingPool' | 'staker'>>;
    createTransferAssetsTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateTransferAssetsTransactionsArgs, 'addresses' | 'to'>>;
    createTransferResourceTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateTransferResourceTransactionArgs, 'amount' | 'owner' | 'recipient' | 'resource'>>;
    createUnstakeCharactersTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateUnstakeCharactersTransactionsArgs, 'characterAddresses' | 'characterModel'>>;
    createUnstakeSplTokensTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUnstakeSplTokensTransactionArgs, 'payer' | 'project' | 'splStakingPool' | 'staker' | 'stakingReciept'>>;
    createUnwrapAssetsFromCharacterTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateUnwrapAssetsFromCharacterTransactionsArgs, 'characterAddresses' | 'characterModel' | 'project' | 'wallet'>>;
    createUpdateBadgeCriteriaTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateBadgeCriteriaTransactionArgs, 'args'>>;
    createUpdateCharacterTraitsTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateCharacterTraitsTransactionArgs, 'assemblerConfig' | 'authority' | 'characterAddress' | 'characterModel' | 'project'>>;
    createUpdateMissionPoolTransaction?: Resolver<ResolversTypes['CreateUpdateMissionPoolTransactionResponse'], ParentType, ContextType, RequireFields<QueryCreateUpdateMissionPoolTransactionArgs, 'data'>>;
    createUpdateMissionTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateMissionTransactionArgs, 'authority' | 'missionAddress' | 'params'>>;
    createUpdatePlatformDataTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdatePlatformDataTransactionArgs, 'authority' | 'profile'>>;
    createUpdateProfileTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateProfileTransactionArgs, 'payer' | 'profile'>>;
    createUpdateSplStakingPoolTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateSplStakingPoolTransactionArgs, 'authority' | 'metadata' | 'project' | 'splStakingPool'>>;
    createUpdateStakingPoolTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateStakingPoolTransactionArgs, 'authority' | 'project' | 'stakingPool'>>;
    createUpdateUserTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUpdateUserTransactionArgs, 'payer'>>;
    createUseCharacterTransaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<QueryCreateUseCharacterTransactionArgs, 'character' | 'characterModel' | 'project' | 'user'>>;
    createWrapAssetsToCharacterTransactions?: Resolver<ResolversTypes['Transactions'], ParentType, ContextType, RequireFields<QueryCreateWrapAssetsToCharacterTransactionsArgs, 'characterModel' | 'mintList' | 'project' | 'wallet'>>;
    delegateAuthority?: Resolver<Array<ResolversTypes['DelegateAuthority']>, ParentType, ContextType, Partial<QueryDelegateAuthorityArgs>>;
    faucets?: Resolver<Array<ResolversTypes['Faucet']>, ParentType, ContextType, Partial<QueryFaucetsArgs>>;
    global?: Resolver<ResolversTypes['Global'], ParentType, ContextType, Partial<QueryGlobalArgs>>;
    holdings?: Resolver<Array<ResolversTypes['Holding']>, ParentType, ContextType, Partial<QueryHoldingsArgs>>;
    mission?: Resolver<Array<ResolversTypes['Mission']>, ParentType, ContextType, Partial<QueryMissionArgs>>;
    missionPool?: Resolver<Array<ResolversTypes['MissionPool']>, ParentType, ContextType, Partial<QueryMissionPoolArgs>>;
    multipliers?: Resolver<Array<ResolversTypes['Multipliers']>, ParentType, ContextType, Partial<QueryMultipliersArgs>>;
    profile?: Resolver<Array<ResolversTypes['Profile']>, ParentType, ContextType, Partial<QueryProfileArgs>>;
    project?: Resolver<Array<ResolversTypes['Project']>, ParentType, ContextType, Partial<QueryProjectArgs>>;
    proof?: Resolver<Array<ResolversTypes['Proof']>, ParentType, ContextType, RequireFields<QueryProofArgs, 'leaves'>>;
    recipes?: Resolver<Array<ResolversTypes['Recipe']>, ParentType, ContextType, Partial<QueryRecipesArgs>>;
    resources?: Resolver<Array<ResolversTypes['Resource']>, ParentType, ContextType, Partial<QueryResourcesArgs>>;
    resourcesBalance?: Resolver<Array<ResolversTypes['ResourceBalance']>, ParentType, ContextType, RequireFields<QueryResourcesBalanceArgs, 'wallets'>>;
    sendBulkTransactions?: Resolver<Array<ResolversTypes['TransactionResponse']>, ParentType, ContextType, RequireFields<QuerySendBulkTransactionsArgs, 'blockhash' | 'lastValidBlockHeight' | 'txs'>>;
    sendTransactionBundles?: Resolver<Array<ResolversTypes['TransactionBundleResponse']>, ParentType, ContextType, RequireFields<QuerySendTransactionBundlesArgs, 'blockhash' | 'lastValidBlockHeight' | 'txs'>>;
    signWithShadowSignerAndSendBulkTransactions?: Resolver<Array<ResolversTypes['TransactionResponse']>, ParentType, ContextType, RequireFields<QuerySignWithShadowSignerAndSendBulkTransactionsArgs, 'blockhash' | 'lastValidBlockHeight' | 'txs'>>;
    signWithShadowSignerAndSendTransactionBundles?: Resolver<Array<ResolversTypes['TransactionBundleResponse']>, ParentType, ContextType, RequireFields<QuerySignWithShadowSignerAndSendTransactionBundlesArgs, 'authToken' | 'blockhash' | 'lastValidBlockHeight' | 'txs'>>;
    splStakingPools?: Resolver<Array<ResolversTypes['SplStakingPool']>, ParentType, ContextType, Partial<QuerySplStakingPoolsArgs>>;
    splStakingRecipients?: Resolver<Array<ResolversTypes['StakingRecipient']>, ParentType, ContextType, Partial<QuerySplStakingRecipientsArgs>>;
    stakers?: Resolver<Array<ResolversTypes['Staker']>, ParentType, ContextType, Partial<QueryStakersArgs>>;
    stakingPools?: Resolver<Array<ResolversTypes['StakingPool']>, ParentType, ContextType, Partial<QueryStakingPoolsArgs>>;
    user?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType, Partial<QueryUserArgs>>;
}>;
export type RecipeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Recipe'] = ResolversParentTypes['Recipe']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    ingredients?: Resolver<Array<ResolversTypes['Ingredient']>, ParentType, ContextType>;
    key?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    meal?: Resolver<ResolversTypes['Meal'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    xp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Resource'] = ResolversParentTypes['Resource']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    kind?: Resolver<ResolversTypes['ResourceKind'], ParentType, ContextType>;
    mint?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    storage?: Resolver<ResolversTypes['ResourceStorage'], ParentType, ContextType>;
    tags?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceBalance'] = ResolversParentTypes['ResourceBalance']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    amount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    mint?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    resourceStorage?: Resolver<ResolversTypes['ResourceStorageEnum'], ParentType, ContextType>;
    wallet?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceCustodyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceCustody'] = ResolversParentTypes['ResourceCustody']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['ResourceCustodyEnum'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['ResourceCustodyParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceCustodyParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceCustodyParams'] = ResolversParentTypes['ResourceCustodyParams']> = ResolversObject<{
    burnerDestination?: Resolver<Maybe<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceKindResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceKind'] = ResolversParentTypes['ResourceKind']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['ResourceKindParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceKindParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceKindParams'] = ResolversParentTypes['ResourceKindParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'ResourceKindParamsHplFungible' | 'ResourceKindParamsHplNonFungible' | 'ResourceKindParamsWrappedFungible' | 'ResourceKindParamsWrappedMplCore', ParentType, ContextType>;
}>;
export type ResourceKindParamsHplFungibleResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceKindParamsHplFungible'] = ResolversParentTypes['ResourceKindParamsHplFungible']> = ResolversObject<{
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceKindParamsHplNonFungibleResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceKindParamsHplNonFungible'] = ResolversParentTypes['ResourceKindParamsHplNonFungible']> = ResolversObject<{
    characteristics?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceKindParamsWrappedFungibleResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceKindParamsWrappedFungible'] = ResolversParentTypes['ResourceKindParamsWrappedFungible']> = ResolversObject<{
    custody?: Resolver<ResolversTypes['ResourceCustody'], ParentType, ContextType>;
    decimals?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceKindParamsWrappedMplCoreResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceKindParamsWrappedMplCore'] = ResolversParentTypes['ResourceKindParamsWrappedMplCore']> = ResolversObject<{
    characteristics?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceRewardTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceRewardType'] = ResolversParentTypes['ResourceRewardType']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<ResolversTypes['ResourceRewardTypeParams'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceRewardTypeParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceRewardTypeParams'] = ResolversParentTypes['ResourceRewardTypeParams']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceStorageResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceStorage'] = ResolversParentTypes['ResourceStorage']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['ResourceStorageEnum'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['ResourceStorageParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ResourceStorageParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ResourceStorageParams'] = ResolversParentTypes['ResourceStorageParams']> = ResolversObject<{
    merkle_trees?: Resolver<ResolversTypes['ControlledMerkleTrees'], ParentType, ContextType>;
    promiseSupply?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type RewardResolvers<ContextType = any, ParentType extends ResolversParentTypes['Reward'] = ResolversParentTypes['Reward']> = ResolversObject<{
    max?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    min?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    rewardType?: Resolver<Maybe<ResolversTypes['RewardType']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type RewardTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RewardType'] = ResolversParentTypes['RewardType']> = ResolversObject<{
    __resolveType: TypeResolveFn<'ResourceRewardType' | 'XpRewardType', ParentType, ContextType>;
}>;
export type SerializableActionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SerializableActions'] = ResolversParentTypes['SerializableActions']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Service'] = ResolversParentTypes['Service']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['ServiceParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceDelegationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceDelegation'] = ResolversParentTypes['ServiceDelegation']> = ResolversObject<{
    index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    permission?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParams'] = ResolversParentTypes['ServiceParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'ServiceParamsAssembler' | 'ServiceParamsAssetManager' | 'ServiceParamsGuildKit' | 'ServiceParamsMissions' | 'ServiceParamsRaffles' | 'ServiceParamsStaking', ParentType, ContextType>;
}>;
export type ServiceParamsAssemblerResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParamsAssembler'] = ResolversParentTypes['ServiceParamsAssembler']> = ResolversObject<{
    assemblerId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceParamsAssetManagerResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParamsAssetManager'] = ResolversParentTypes['ServiceParamsAssetManager']> = ResolversObject<{
    assetManagerId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceParamsGuildKitResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParamsGuildKit'] = ResolversParentTypes['ServiceParamsGuildKit']> = ResolversObject<{
    kitId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceParamsMissionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParamsMissions'] = ResolversParentTypes['ServiceParamsMissions']> = ResolversObject<{
    poolId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceParamsRafflesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParamsRaffles'] = ResolversParentTypes['ServiceParamsRaffles']> = ResolversObject<{
    poolId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type ServiceParamsStakingResolvers<ContextType = any, ParentType extends ResolversParentTypes['ServiceParamsStaking'] = ResolversParentTypes['ServiceParamsStaking']> = ResolversObject<{
    poolId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SocialInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['SocialInfo'] = ResolversParentTypes['SocialInfo']> = ResolversObject<{
    civic?: Resolver<Maybe<Array<Maybe<ResolversTypes['CivicInfo']>>>, ParentType, ContextType>;
    discord?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    steam?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    twitter?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplMultiplierResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplMultiplier'] = ResolversParentTypes['SplMultiplier']> = ResolversObject<{
    multiplierType?: Resolver<ResolversTypes['SplMultiplierType'], ParentType, ContextType>;
    value?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplMultiplierTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplMultiplierType'] = ResolversParentTypes['SplMultiplierType']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<ResolversTypes['SplMultiplierTypeParams'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplMultiplierTypeParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplMultiplierTypeParams'] = ResolversParentTypes['SplMultiplierTypeParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'SplMultiplierTypeParamsStakeAmount' | 'SplMultiplierTypeParamsStakeDuration', ParentType, ContextType>;
}>;
export type SplMultiplierTypeParamsStakeAmountResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplMultiplierTypeParamsStakeAmount'] = ResolversParentTypes['SplMultiplierTypeParamsStakeAmount']> = ResolversObject<{
    minAmount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplMultiplierTypeParamsStakeDurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplMultiplierTypeParamsStakeDuration'] = ResolversParentTypes['SplMultiplierTypeParamsStakeDuration']> = ResolversObject<{
    minDuration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplRewardConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplRewardConfig'] = ResolversParentTypes['SplRewardConfig']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['SplRewardConfigParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplRewardConfigParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplRewardConfigParams'] = ResolversParentTypes['SplRewardConfigParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'SplRewardConfigParamsApy' | 'SplRewardConfigParamsNotSet' | 'SplRewardConfigParamsStakeWeight', ParentType, ContextType>;
}>;
export type SplRewardConfigParamsApyResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplRewardConfigParamsApy'] = ResolversParentTypes['SplRewardConfigParamsApy']> = ResolversObject<{
    rewardTokenMint?: Resolver<Maybe<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    rewardVault?: Resolver<Maybe<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    rewardsDuration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    rewardsPerDuration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    totalRewardAmount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplRewardConfigParamsNotSetResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplRewardConfigParamsNotSet'] = ResolversParentTypes['SplRewardConfigParamsNotSet']> = ResolversObject<{
    notSet?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplRewardConfigParamsStakeWeightResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplRewardConfigParamsStakeWeight'] = ResolversParentTypes['SplRewardConfigParamsStakeWeight']> = ResolversObject<{
    pools?: Resolver<Array<ResolversTypes['SplStakeWeightConfig']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplStakeWeightConfigResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplStakeWeightConfig'] = ResolversParentTypes['SplStakeWeightConfig']> = ResolversObject<{
    weight?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type SplStakingPoolResolvers<ContextType = any, ParentType extends ResolversParentTypes['SplStakingPool'] = ResolversParentTypes['SplStakingPool']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    endTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    maxStakeDurationSecs?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    merkleTrees?: Resolver<ResolversTypes['ControlledMerkleTrees'], ParentType, ContextType>;
    minStakeDurationSecs?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    multipliers?: Resolver<Array<ResolversTypes['SplMultiplier']>, ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    nonce?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    rewardConfig?: Resolver<ResolversTypes['SplRewardConfig'], ParentType, ContextType>;
    stake_token_mint?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    startTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    totalStakedAmount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakerResolvers<ContextType = any, ParentType extends ResolversParentTypes['Staker'] = ResolversParentTypes['Staker']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    stakingPool?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    totalStaked?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    wallet?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakerClaimedResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakerClaimed'] = ResolversParentTypes['StakerClaimed']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<Maybe<ResolversTypes['StakerClaimedParams']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakerClaimedParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakerClaimedParams'] = ResolversParentTypes['StakerClaimedParams']> = ResolversObject<{
    __resolveType: TypeResolveFn<'StakerClaimedParamsApy' | 'StakerClaimedParamsNone' | 'StakerClaimedParamsStakeWeight', ParentType, ContextType>;
}>;
export type StakerClaimedParamsApyResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakerClaimedParamsApy'] = ResolversParentTypes['StakerClaimedParamsApy']> = ResolversObject<{
    lastRewardTime?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakerClaimedParamsNoneResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakerClaimedParamsNone'] = ResolversParentTypes['StakerClaimedParamsNone']> = ResolversObject<{
    none?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakerClaimedParamsStakeWeightResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakerClaimedParamsStakeWeight'] = ResolversParentTypes['StakerClaimedParamsStakeWeight']> = ResolversObject<{
    amounts?: Resolver<Array<Maybe<ResolversTypes['BigInt']>>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakingPoolResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakingPool'] = ResolversParentTypes['StakingPool']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    allowedMints?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    bump?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    characterModels?: Resolver<Array<Maybe<ResolversTypes['Pubkey']>>, ParentType, ContextType>;
    cooldownDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    endTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    key?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    lockType?: Resolver<ResolversTypes['LockType'], ParentType, ContextType>;
    maxRewardsDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    minStakeDuration?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    project?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    resetStakeDuration?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
    resource?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    rewardsDuration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    rewardsPerDuration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    startTime?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
    totalStaked?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type StakingRecipientResolvers<ContextType = any, ParentType extends ResolversParentTypes['StakingRecipient'] = ResolversParentTypes['StakingRecipient']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    leaf_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    lokedTill?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    multiplier?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    proof?: Resolver<Maybe<ResolversTypes['Proof']>, ParentType, ContextType>;
    rewardsClaimed?: Resolver<ResolversTypes['StakerClaimed'], ParentType, ContextType>;
    stakeStartTime?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    stakedAmount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    staker?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export interface StringTupleScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['StringTuple'], any> {
    name: 'StringTuple';
}
export type TimeRequirementResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeRequirement'] = ResolversParentTypes['TimeRequirement']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    params?: Resolver<ResolversTypes['TimeRequirementParams'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type TimeRequirementParamsResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimeRequirementParams'] = ResolversParentTypes['TimeRequirementParams']> = ResolversObject<{
    duration?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type TransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = ResolversObject<{
    blockhash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    lastValidBlockHeight?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    transaction?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type TransactionBundleResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionBundleResponse'] = ResolversParentTypes['TransactionBundleResponse']> = ResolversObject<{
    bundleId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    responses?: Resolver<Array<ResolversTypes['TransactionResponse']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type TransactionResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionResponse'] = ResolversParentTypes['TransactionResponse']> = ResolversObject<{
    error?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
    signature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
    status?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type TransactionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Transactions'] = ResolversParentTypes['Transactions']> = ResolversObject<{
    blockhash?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    lastValidBlockHeight?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    transactions?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type TreeSetupResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['TreeSetupResponse'] = ResolversParentTypes['TreeSetupResponse']> = ResolversObject<{
    cost?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
    maxTreeCapacity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    proofBytes?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    space?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    treeAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    tx?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UsedByCustomResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsedByCustom'] = ResolversParentTypes['UsedByCustom']> = ResolversObject<{
    data?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
    user?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UsedByEjectedResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsedByEjected'] = ResolversParentTypes['UsedByEjected']> = ResolversObject<{
    mint?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UsedByGuildResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsedByGuild'] = ResolversParentTypes['UsedByGuild']> = ResolversObject<{
    id?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    order?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    role?: Resolver<ResolversTypes['GuildRole'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UsedByMissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsedByMission'] = ResolversParentTypes['UsedByMission']> = ResolversObject<{
    endTime?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    missionId?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    participationId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    rewards?: Resolver<Array<ResolversTypes['EarnedRewards']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UsedByStakingResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsedByStaking'] = ResolversParentTypes['UsedByStaking']> = ResolversObject<{
    claimedAt?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    pool?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    stakedAt?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    staker?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = ResolversObject<{
    address?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
    info?: Resolver<ResolversTypes['UserInfo'], ParentType, ContextType>;
    leaf_idx?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;
    profiles?: Resolver<Maybe<Array<Maybe<ResolversTypes['Profile']>>>, ParentType, ContextType>;
    proof?: Resolver<Maybe<ResolversTypes['Proof']>, ParentType, ContextType>;
    socialInfo?: Resolver<ResolversTypes['SocialInfo'], ParentType, ContextType>;
    tree_id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;
    wallets?: Resolver<ResolversTypes['Wallets'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type UserInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserInfo'] = ResolversParentTypes['UserInfo']> = ResolversObject<{
    bio?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    pfp?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    username?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export interface VecMapScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['VecMap'], any> {
    name: 'VecMap';
}
export interface VecMapGenericScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['VecMapGeneric'], any> {
    name: 'VecMapGeneric';
}
export type WalletsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Wallets'] = ResolversParentTypes['Wallets']> = ResolversObject<{
    shadow?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    wallets?: Resolver<Array<ResolversTypes['Pubkey']>, ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type WrappedResolvers<ContextType = any, ParentType extends ResolversParentTypes['Wrapped'] = ResolversParentTypes['Wrapped']> = ResolversObject<{
    criteria?: Resolver<ResolversTypes['AssetCriteria'], ParentType, ContextType>;
    kind?: Resolver<Maybe<ResolversTypes['SourceKind']>, ParentType, ContextType>;
    mint?: Resolver<ResolversTypes['Pubkey'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type XpRewardTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['XpRewardType'] = ResolversParentTypes['XpRewardType']> = ResolversObject<{
    kind?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;
export type Resolvers<ContextType = any> = ResolversObject<{
    Account?: AccountResolvers<ContextType>;
    Assembled?: AssembledResolvers<ContextType>;
    AssemblerConfig?: AssemblerConfigResolvers<ContextType>;
    AssetCriteria?: AssetCriteriaResolvers<ContextType>;
    AssociatedProgram?: AssociatedProgramResolvers<ContextType>;
    AuthConfirmed?: AuthConfirmedResolvers<ContextType>;
    AuthResponse?: AuthResponseResolvers<ContextType>;
    BadgeCriteria?: BadgeCriteriaResolvers<ContextType>;
    BigInt?: GraphQLScalarType;
    Bytes?: GraphQLScalarType;
    Character?: CharacterResolvers<ContextType>;
    CharacterConfig?: CharacterConfigResolvers<ContextType>;
    CharacterConfigAssembled?: CharacterConfigAssembledResolvers<ContextType>;
    CharacterConfigWrapped?: CharacterConfigWrappedResolvers<ContextType>;
    CharacterCooldown?: CharacterCooldownResolvers<ContextType>;
    CharacterHistory?: CharacterHistoryResolvers<ContextType>;
    CharacterModel?: CharacterModelResolvers<ContextType>;
    CharacterSource?: CharacterSourceResolvers<ContextType>;
    CharacterSourceParams?: CharacterSourceParamsResolvers<ContextType>;
    CharacterTrait?: CharacterTraitResolvers<ContextType>;
    CharacterUsedBy?: CharacterUsedByResolvers<ContextType>;
    CharacterUsedByParams?: CharacterUsedByParamsResolvers<ContextType>;
    CivicInfo?: CivicInfoResolvers<ContextType>;
    CompressedAccount?: CompressedAccountResolvers<ContextType>;
    ControlledMerkleTrees?: ControlledMerkleTreesResolvers<ContextType>;
    CreateAssemblerConfigTransactionResponse?: CreateAssemblerConfigTransactionResponseResolvers<ContextType>;
    CreateBeginCookingTransactionResponse?: CreateBeginCookingTransactionResponseResolvers<ContextType>;
    CreateCharacterModelTransactionResponse?: CreateCharacterModelTransactionResponseResolvers<ContextType>;
    CreateCreateHolderAccountTransactionResponse?: CreateCreateHolderAccountTransactionResponseResolvers<ContextType>;
    CreateCreateMissionPoolTransactionResponse?: CreateCreateMissionPoolTransactionResponseResolvers<ContextType>;
    CreateCreateMissionTransactionResponse?: CreateCreateMissionTransactionResponseResolvers<ContextType>;
    CreateCreateNewResourceTreeTransactionResponse?: CreateCreateNewResourceTreeTransactionResponseResolvers<ContextType>;
    CreateCreateProjectTransactionResponse?: CreateCreateProjectTransactionResponseResolvers<ContextType>;
    CreateCreateSplStakingPoolTransactionResponse?: CreateCreateSplStakingPoolTransactionResponseResolvers<ContextType>;
    CreateCreateStakingPoolTransactionResponse?: CreateCreateStakingPoolTransactionResponseResolvers<ContextType>;
    CreateInitMultipliersTransactionResponse?: CreateInitMultipliersTransactionResponseResolvers<ContextType>;
    CreateInitResourceTransactionResponse?: CreateInitResourceTransactionResponseResolvers<ContextType>;
    CreateInitializeFaucetTransactionResponse?: CreateInitializeFaucetTransactionResponseResolvers<ContextType>;
    CreateInitializeRecipeTransactionResponse?: CreateInitializeRecipeTransactionResponseResolvers<ContextType>;
    CreateUpdateMissionPoolTransactionResponse?: CreateUpdateMissionPoolTransactionResponseResolvers<ContextType>;
    CreateUpdateMissionTransactionResponse?: CreateUpdateMissionTransactionResponseResolvers<ContextType>;
    DelegateAuthority?: DelegateAuthorityResolvers<ContextType>;
    EarnedRewards?: EarnedRewardsResolvers<ContextType>;
    Faucet?: FaucetResolvers<ContextType>;
    Global?: GlobalResolvers<ContextType>;
    GuildRole?: GuildRoleResolvers<ContextType>;
    Holding?: HoldingResolvers<ContextType>;
    Ingredient?: IngredientResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    LockType?: LockTypeResolvers<ContextType>;
    Meal?: MealResolvers<ContextType>;
    MintAs?: MintAsResolvers<ContextType>;
    MintAsParams?: MintAsParamsResolvers<ContextType>;
    MintAsParamsMplBubblegum?: MintAsParamsMplBubblegumResolvers<ContextType>;
    Mission?: MissionResolvers<ContextType>;
    MissionCost?: MissionCostResolvers<ContextType>;
    MissionPool?: MissionPoolResolvers<ContextType>;
    MissionRequirement?: MissionRequirementResolvers<ContextType>;
    Multiplier?: MultiplierResolvers<ContextType>;
    MultiplierType?: MultiplierTypeResolvers<ContextType>;
    MultiplierTypeParams?: MultiplierTypeParamsResolvers<ContextType>;
    MultiplierTypeParamsCollection?: MultiplierTypeParamsCollectionResolvers<ContextType>;
    MultiplierTypeParamsCreator?: MultiplierTypeParamsCreatorResolvers<ContextType>;
    MultiplierTypeParamsNFTCount?: MultiplierTypeParamsNftCountResolvers<ContextType>;
    MultiplierTypeParamsStakeDuration?: MultiplierTypeParamsStakeDurationResolvers<ContextType>;
    Multipliers?: MultipliersResolvers<ContextType>;
    NftCreator?: NftCreatorResolvers<ContextType>;
    Node?: NodeResolvers<ContextType>;
    OutputHolding?: OutputHoldingResolvers<ContextType>;
    OutputHoldingTree?: OutputHoldingTreeResolvers<ContextType>;
    PlatformData?: PlatformDataResolvers<ContextType>;
    Profile?: ProfileResolvers<ContextType>;
    ProfileDataConfig?: ProfileDataConfigResolvers<ContextType>;
    ProfileInfo?: ProfileInfoResolvers<ContextType>;
    Project?: ProjectResolvers<ContextType>;
    Proof?: ProofResolvers<ContextType>;
    Pubkey?: GraphQLScalarType;
    Query?: QueryResolvers<ContextType>;
    Recipe?: RecipeResolvers<ContextType>;
    Resource?: ResourceResolvers<ContextType>;
    ResourceBalance?: ResourceBalanceResolvers<ContextType>;
    ResourceCustody?: ResourceCustodyResolvers<ContextType>;
    ResourceCustodyParams?: ResourceCustodyParamsResolvers<ContextType>;
    ResourceKind?: ResourceKindResolvers<ContextType>;
    ResourceKindParams?: ResourceKindParamsResolvers<ContextType>;
    ResourceKindParamsHplFungible?: ResourceKindParamsHplFungibleResolvers<ContextType>;
    ResourceKindParamsHplNonFungible?: ResourceKindParamsHplNonFungibleResolvers<ContextType>;
    ResourceKindParamsWrappedFungible?: ResourceKindParamsWrappedFungibleResolvers<ContextType>;
    ResourceKindParamsWrappedMplCore?: ResourceKindParamsWrappedMplCoreResolvers<ContextType>;
    ResourceRewardType?: ResourceRewardTypeResolvers<ContextType>;
    ResourceRewardTypeParams?: ResourceRewardTypeParamsResolvers<ContextType>;
    ResourceStorage?: ResourceStorageResolvers<ContextType>;
    ResourceStorageParams?: ResourceStorageParamsResolvers<ContextType>;
    Reward?: RewardResolvers<ContextType>;
    RewardType?: RewardTypeResolvers<ContextType>;
    SerializableActions?: SerializableActionsResolvers<ContextType>;
    Service?: ServiceResolvers<ContextType>;
    ServiceDelegation?: ServiceDelegationResolvers<ContextType>;
    ServiceParams?: ServiceParamsResolvers<ContextType>;
    ServiceParamsAssembler?: ServiceParamsAssemblerResolvers<ContextType>;
    ServiceParamsAssetManager?: ServiceParamsAssetManagerResolvers<ContextType>;
    ServiceParamsGuildKit?: ServiceParamsGuildKitResolvers<ContextType>;
    ServiceParamsMissions?: ServiceParamsMissionsResolvers<ContextType>;
    ServiceParamsRaffles?: ServiceParamsRafflesResolvers<ContextType>;
    ServiceParamsStaking?: ServiceParamsStakingResolvers<ContextType>;
    SocialInfo?: SocialInfoResolvers<ContextType>;
    SplMultiplier?: SplMultiplierResolvers<ContextType>;
    SplMultiplierType?: SplMultiplierTypeResolvers<ContextType>;
    SplMultiplierTypeParams?: SplMultiplierTypeParamsResolvers<ContextType>;
    SplMultiplierTypeParamsStakeAmount?: SplMultiplierTypeParamsStakeAmountResolvers<ContextType>;
    SplMultiplierTypeParamsStakeDuration?: SplMultiplierTypeParamsStakeDurationResolvers<ContextType>;
    SplRewardConfig?: SplRewardConfigResolvers<ContextType>;
    SplRewardConfigParams?: SplRewardConfigParamsResolvers<ContextType>;
    SplRewardConfigParamsApy?: SplRewardConfigParamsApyResolvers<ContextType>;
    SplRewardConfigParamsNotSet?: SplRewardConfigParamsNotSetResolvers<ContextType>;
    SplRewardConfigParamsStakeWeight?: SplRewardConfigParamsStakeWeightResolvers<ContextType>;
    SplStakeWeightConfig?: SplStakeWeightConfigResolvers<ContextType>;
    SplStakingPool?: SplStakingPoolResolvers<ContextType>;
    Staker?: StakerResolvers<ContextType>;
    StakerClaimed?: StakerClaimedResolvers<ContextType>;
    StakerClaimedParams?: StakerClaimedParamsResolvers<ContextType>;
    StakerClaimedParamsApy?: StakerClaimedParamsApyResolvers<ContextType>;
    StakerClaimedParamsNone?: StakerClaimedParamsNoneResolvers<ContextType>;
    StakerClaimedParamsStakeWeight?: StakerClaimedParamsStakeWeightResolvers<ContextType>;
    StakingPool?: StakingPoolResolvers<ContextType>;
    StakingRecipient?: StakingRecipientResolvers<ContextType>;
    StringTuple?: GraphQLScalarType;
    TimeRequirement?: TimeRequirementResolvers<ContextType>;
    TimeRequirementParams?: TimeRequirementParamsResolvers<ContextType>;
    Transaction?: TransactionResolvers<ContextType>;
    TransactionBundleResponse?: TransactionBundleResponseResolvers<ContextType>;
    TransactionResponse?: TransactionResponseResolvers<ContextType>;
    Transactions?: TransactionsResolvers<ContextType>;
    TreeSetupResponse?: TreeSetupResponseResolvers<ContextType>;
    UsedByCustom?: UsedByCustomResolvers<ContextType>;
    UsedByEjected?: UsedByEjectedResolvers<ContextType>;
    UsedByGuild?: UsedByGuildResolvers<ContextType>;
    UsedByMission?: UsedByMissionResolvers<ContextType>;
    UsedByStaking?: UsedByStakingResolvers<ContextType>;
    User?: UserResolvers<ContextType>;
    UserInfo?: UserInfoResolvers<ContextType>;
    VecMap?: GraphQLScalarType;
    VecMapGeneric?: GraphQLScalarType;
    Wallets?: WalletsResolvers<ContextType>;
    Wrapped?: WrappedResolvers<ContextType>;
    XpRewardType?: XpRewardTypeResolvers<ContextType>;
}>;
export type FindCompressedAccountsQueryVariables = Exact<{
    addresses: Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input'];
    identity?: InputMaybe<DisrcriminatorFilter>;
    leaves?: InputMaybe<Array<TreeLeaf> | TreeLeaf>;
    parsedData?: InputMaybe<Scalars['JSON']['input']>;
}>;
export type FindCompressedAccountsQuery = {
    __typename?: 'Query';
    compressedAccount: Array<{
        __typename?: 'CompressedAccount';
        leaf_idx?: string | null;
        parsed_data?: any | null;
        raw_data?: string | null;
        schema_validated?: boolean | null;
        tree_id?: string | null;
    }>;
};
export type FetchProofsQueryVariables = Exact<{
    leaves: Array<TreeLeaf> | TreeLeaf;
}>;
export type FetchProofsQuery = {
    __typename?: 'Query';
    proof: Array<{
        __typename?: 'Proof';
        root: string;
        proof: Array<string>;
        maxDepth: number;
        node_index: string;
        leaf: string;
        leaf_index: string;
        tree_id: string;
        canopy_depth: number;
    }>;
};
export type FindAccountsQueryVariables = Exact<{
    programId: Scalars['Bytes']['input'];
    discriminator?: InputMaybe<Scalars['Bytes']['input']>;
    parsedData?: InputMaybe<Scalars['JSON']['input']>;
}>;
export type FindAccountsQuery = {
    __typename?: 'Query';
    account: Array<{
        __typename?: 'Account';
        address: string;
        program_id: string;
        discriminator: string;
        parsed_data?: any | null;
    }>;
};
export type SendTransactionBundlesQueryVariables = Exact<{
    txs: Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input'];
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
}>;
export type SendTransactionBundlesQuery = {
    __typename?: 'Query';
    sendTransactionBundles: Array<{
        __typename?: 'TransactionBundleResponse';
        bundleId: number;
        responses: Array<{
            __typename?: 'TransactionResponse';
            signature?: string | null;
            error?: any | null;
            status: string;
        }>;
    }>;
};
export type SignWithShadowSignerAndSendTransactionBundlesQueryVariables = Exact<{
    txs: Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input'];
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    authToken: Scalars['String']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
}>;
export type SignWithShadowSignerAndSendTransactionBundlesQuery = {
    __typename?: 'Query';
    signWithShadowSignerAndSendTransactionBundles: Array<{
        __typename?: 'TransactionBundleResponse';
        bundleId: number;
        responses: Array<{
            __typename?: 'TransactionResponse';
            signature?: string | null;
            error?: any | null;
            status: string;
        }>;
    }>;
};
export type SendBulkTransactionsQueryVariables = Exact<{
    txs: Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input'];
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
}>;
export type SendBulkTransactionsQuery = {
    __typename?: 'Query';
    sendBulkTransactions: Array<{
        __typename?: 'TransactionResponse';
        signature?: string | null;
        error?: any | null;
        status: string;
    }>;
};
export type SignWithShadowSignerAndSendBulkTransactionsQueryVariables = Exact<{
    txs: Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input'];
    blockhash: Scalars['String']['input'];
    lastValidBlockHeight: Scalars['Int']['input'];
    options?: InputMaybe<SendTransactionBundlesOptions>;
}>;
export type SignWithShadowSignerAndSendBulkTransactionsQuery = {
    __typename?: 'Query';
    signWithShadowSignerAndSendBulkTransactions: Array<{
        __typename?: 'TransactionResponse';
        signature?: string | null;
        error?: any | null;
        status: string;
    }>;
};
export type AuthRequestQueryVariables = Exact<{
    wallet: Scalars['String']['input'];
    useTx?: InputMaybe<Scalars['Boolean']['input']>;
    useRpc?: InputMaybe<Scalars['String']['input']>;
}>;
export type AuthRequestQuery = {
    __typename?: 'Query';
    authRequest: {
        __typename?: 'AuthResponse';
        message: string;
        tx?: string | null;
    };
};
export type AuthConfirmQueryVariables = Exact<{
    wallet: Scalars['String']['input'];
    signature: Scalars['String']['input'];
}>;
export type AuthConfirmQuery = {
    __typename?: 'Query';
    authConfirm: {
        __typename?: 'AuthConfirmed';
        accessToken: string;
        user: {
            __typename?: 'User';
            address: string;
            id: number;
            info: {
                __typename?: 'UserInfo';
                bio: string;
                name: string;
                pfp: string;
            };
            wallets: {
                __typename?: 'Wallets';
                shadow: string;
                wallets: Array<string>;
            };
        };
    };
};
export type CreateTransferAssetsTransactionsQueryVariables = Exact<{
    addresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    to: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateTransferAssetsTransactionsQuery = {
    __typename?: 'Query';
    createTransferAssetsTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateBurnAssetsTransactionsQueryVariables = Exact<{
    addresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateBurnAssetsTransactionsQuery = {
    __typename?: 'Query';
    createBurnAssetsTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type FindGlobalQueryVariables = Exact<{
    env?: InputMaybe<Scalars['String']['input']>;
}>;
export type FindGlobalQuery = {
    __typename?: 'Query';
    global: {
        __typename?: 'Global';
        address: string;
        bump: number;
        config: Record<string, any>;
        totalUsers: number;
        userTrees: {
            __typename?: 'ControlledMerkleTrees';
            active: number;
            merkle_trees: Array<string>;
            schema: any;
        };
    };
};
export type FindProjectsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    names?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    authorities?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindProjectsQuery = {
    __typename?: 'Query';
    project: Array<{
        __typename?: 'Project';
        authority: string;
        bump: number;
        driver: string;
        address: string;
        key: string;
        name: string;
        subsidyFees: boolean;
        associatedPrograms: Array<{
            __typename?: 'AssociatedProgram';
            address: string;
            trustedActions: Array<{
                __typename?: 'SerializableActions';
                kind: string;
            }>;
        }>;
        profileDataConfig: {
            __typename?: 'ProfileDataConfig';
            achievements: Array<string>;
            customDataFields: Array<string>;
        };
        profileTrees: {
            __typename?: 'ControlledMerkleTrees';
            active: number;
            merkle_trees: Array<string>;
            schema: any;
        };
        badgeCriteria?: Array<{
            __typename?: 'BadgeCriteria';
            index: number;
            condition: BadgesCondition;
            endTime: string;
            startTime: string;
        }> | null;
        services: Array<{
            __typename?: 'Service';
            kind: string;
            params?: {
                __typename?: 'ServiceParamsAssembler';
                assemblerId: string;
            } | {
                __typename?: 'ServiceParamsAssetManager';
                assetManagerId: string;
            } | {
                __typename?: 'ServiceParamsGuildKit';
                kitId: string;
            } | {
                __typename?: 'ServiceParamsMissions';
                poolId: string;
            } | {
                __typename?: 'ServiceParamsRaffles';
                poolId: string;
            } | {
                __typename?: 'ServiceParamsStaking';
                poolId: string;
            } | null;
        }>;
    }>;
};
export type FindDelegateAuthorityQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    delegates?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindDelegateAuthorityQuery = {
    __typename?: 'Query';
    delegateAuthority: Array<{
        __typename?: 'DelegateAuthority';
        authority: string;
        bump: number;
        delegations: Array<{
            __typename?: 'ServiceDelegation';
            kind: string;
            index?: number | null;
            permission: string;
        }>;
    }>;
};
export type FindUsersQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    ids?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
    wallets?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    includeProjectProfiles?: InputMaybe<Array<InputMaybe<Scalars['Pubkey']['input']>> | InputMaybe<Scalars['Pubkey']['input']>>;
}>;
export type FindUsersQuery = {
    __typename?: 'Query';
    user: Array<{
        __typename?: 'User';
        address: string;
        id: number;
        leaf_idx: string;
        tree_id: string;
        info: {
            __typename?: 'UserInfo';
            bio: string;
            name: string;
            pfp: string;
            username: string;
        };
        socialInfo: {
            __typename?: 'SocialInfo';
            discord?: string | null;
            twitter?: string | null;
            steam?: string | null;
            civic?: Array<{
                __typename?: 'CivicInfo';
                expiry?: string | null;
                gatekeeperNetwork: CivicGateway;
                walletIndex: number;
            } | null> | null;
        };
        wallets: {
            __typename?: 'Wallets';
            shadow: string;
            wallets: Array<string>;
        };
        profiles?: Array<{
            __typename?: 'Profile';
            customData: Record<string, any>;
            address: string;
            identity: string;
            project: string;
            userId: number;
            leaf_idx: string;
            tree_id: string;
            info: {
                __typename?: 'ProfileInfo';
                bio?: string | null;
                name?: string | null;
                pfp?: string | null;
            };
            platformData: {
                __typename?: 'PlatformData';
                achievements: Array<number>;
                custom: Record<string, any>;
                xp: string;
            };
            proof?: {
                __typename?: 'Proof';
                leaf: string;
                leaf_index: string;
                node_index: string;
                proof: Array<string>;
                maxDepth: number;
                root: string;
                tree_id: string;
                canopy_depth: number;
            } | null;
        } | null> | null;
        proof?: {
            __typename?: 'Proof';
            leaf: string;
            leaf_index: string;
            node_index: string;
            maxDepth: number;
            proof: Array<string>;
            root: string;
            tree_id: string;
            canopy_depth: number;
        } | null;
    }>;
};
export type FindProfilesQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    userIds?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
    identities?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    includeUsers?: InputMaybe<Scalars['Boolean']['input']>;
}>;
export type FindProfilesQuery = {
    __typename?: 'Query';
    profile: Array<{
        __typename?: 'Profile';
        customData: Record<string, any>;
        address: string;
        identity: string;
        project: string;
        userId: number;
        leaf_idx: string;
        tree_id: string;
        info: {
            __typename?: 'ProfileInfo';
            bio?: string | null;
            name?: string | null;
            pfp?: string | null;
        };
        platformData: {
            __typename?: 'PlatformData';
            achievements: Array<number>;
            custom: Record<string, any>;
            xp: string;
        };
        proof?: {
            __typename?: 'Proof';
            leaf: string;
            leaf_index: string;
            node_index: string;
            proof: Array<string>;
            maxDepth: number;
            root: string;
            tree_id: string;
            canopy_depth: number;
        } | null;
        user?: {
            __typename?: 'User';
            address: string;
            id: number;
            leaf_idx: string;
            tree_id: string;
            info: {
                __typename?: 'UserInfo';
                bio: string;
                name: string;
                pfp: string;
                username: string;
            };
            socialInfo: {
                __typename?: 'SocialInfo';
                discord?: string | null;
                twitter?: string | null;
                steam?: string | null;
                civic?: Array<{
                    __typename?: 'CivicInfo';
                    expiry?: string | null;
                    gatekeeperNetwork: CivicGateway;
                    walletIndex: number;
                } | null> | null;
            };
            wallets: {
                __typename?: 'Wallets';
                shadow: string;
                wallets: Array<string>;
            };
            proof?: {
                __typename?: 'Proof';
                leaf: string;
                leaf_index: string;
                node_index: string;
                maxDepth: number;
                proof: Array<string>;
                root: string;
                tree_id: string;
                canopy_depth: number;
            } | null;
        } | null;
    }>;
};
export type CreateNewUserTransactionQueryVariables = Exact<{
    wallet: Scalars['String']['input'];
    info?: InputMaybe<UserInfoInput>;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateNewUserTransactionQuery = {
    __typename?: 'Query';
    createNewUserTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateNewUserBulkTransactionQueryVariables = Exact<{
    wallet: Array<Scalars['String']['input']> | Scalars['String']['input'];
    info: Array<UserInfoInput> | UserInfoInput;
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateNewUserBulkTransactionQuery = {
    __typename?: 'Query';
    createNewUserBulkTransaction: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateUpdateUserTransactionQueryVariables = Exact<{
    info?: InputMaybe<PartialUserInfoInput>;
    wallets?: InputMaybe<UpdateWalletInput>;
    payer: Scalars['String']['input'];
    populateCivic?: InputMaybe<Scalars['Boolean']['input']>;
    removeSocials?: InputMaybe<Array<RemoveSocialsInput> | RemoveSocialsInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateUserTransactionQuery = {
    __typename?: 'Query';
    createUpdateUserTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateCreateProjectTransactionQueryVariables = Exact<{
    authority: Scalars['String']['input'];
    name: Scalars['String']['input'];
    driver?: InputMaybe<Scalars['String']['input']>;
    associatedPrograms?: InputMaybe<Array<AssociatedProgramInput> | AssociatedProgramInput>;
    profileDataConfig?: InputMaybe<ProfileDataConfigInput>;
    subsidizeFees?: InputMaybe<Scalars['Boolean']['input']>;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateProjectTransactionQuery = {
    __typename?: 'Query';
    createCreateProjectTransaction: {
        __typename?: 'CreateCreateProjectTransactionResponse';
        project: string;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateChangeProjectDriverTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    driver: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateChangeProjectDriverTransactionQuery = {
    __typename?: 'Query';
    createChangeProjectDriverTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateCreateDelegateAuthorityTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    delegate: Scalars['String']['input'];
    serviceDelegations: ServiceDelegationInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateDelegateAuthorityTransactionQuery = {
    __typename?: 'Query';
    createCreateDelegateAuthorityTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateModifyDelegationTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    delegate: Scalars['String']['input'];
    modifyDelegation: ModifyDelegationInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateModifyDelegationTransactionQuery = {
    __typename?: 'Query';
    createModifyDelegationTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateCreateProfilesTreeTransactionQueryVariables = Exact<{
    treeConfig: TreeSetupConfig;
    project: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateProfilesTreeTransactionQuery = {
    __typename?: 'Query';
    createCreateProfilesTreeTransaction: {
        __typename?: 'TreeSetupResponse';
        treeAddress: string;
        proofBytes: number;
        space: number;
        cost?: number | null;
        maxTreeCapacity: number;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateNewProfileTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    identity?: InputMaybe<Scalars['String']['input']>;
    info?: InputMaybe<ProfileInfoInput>;
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateNewProfileTransactionQuery = {
    __typename?: 'Query';
    createNewProfileTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateUpdateProfileTransactionQueryVariables = Exact<{
    profile: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    info?: InputMaybe<ProfileInfoInput>;
    customData?: InputMaybe<CustomDataInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateProfileTransactionQuery = {
    __typename?: 'Query';
    createUpdateProfileTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateUpdatePlatformDataTransactionQueryVariables = Exact<{
    profile: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    platformData?: InputMaybe<PlatformDataInput>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdatePlatformDataTransactionQuery = {
    __typename?: 'Query';
    createUpdatePlatformDataTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateNewUserWithProfileTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    wallet: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    userInfo: UserInfoInput;
    profileIdentity?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateNewUserWithProfileTransactionQuery = {
    __typename?: 'Query';
    createNewUserWithProfileTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type FindAssemblerConfigQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    tickers?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    characterModel?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    project?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindAssemblerConfigQuery = {
    __typename?: 'Query';
    assemblerConfig: Array<{
        __typename?: 'AssemblerConfig';
        address: string;
        program_id: string;
        discriminator: string;
        ticker: string;
        project: string;
        order?: Array<string> | null;
        merkle_trees?: {
            __typename?: 'ControlledMerkleTrees';
            active: number;
            merkle_trees: Array<string>;
            schema: any;
        } | null;
    }>;
};
export type FindCharacterTraitsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
}>;
export type FindCharacterTraitsQuery = {
    __typename?: 'Query';
    characterTrait: Array<{
        __typename?: 'CharacterTrait';
        address: string;
        layer: string;
        leaf_idx: string;
        name: string;
        tree_id: string;
        uri: string;
        proof?: {
            __typename?: 'Proof';
            root: string;
            proof: Array<string>;
            node_index: string;
            leaf: string;
            maxDepth: number;
            leaf_index: string;
            tree_id: string;
            canopy_depth: number;
        } | null;
    }>;
};
export type FindCharacterModelsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    project?: InputMaybe<Scalars['Pubkey']['input']>;
    assemblerConfigs?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindCharacterModelsQuery = {
    __typename?: 'Query';
    characterModel: Array<{
        __typename?: 'CharacterModel';
        address: string;
        program_id: string;
        discriminator: string;
        bump: number;
        key: string;
        equipableCriteria: Array<string>;
        project: string;
        attributes: Array<[any, any]>;
        merkle_trees: {
            __typename?: 'ControlledMerkleTrees';
            active: number;
            merkle_trees: Array<string>;
            schema: any;
        };
        cooldown: {
            __typename?: 'CharacterCooldown';
            ejection: number;
        };
        config: {
            __typename?: 'CharacterConfigAssembled';
            kind: string;
            assemblerConfig: string;
            name: string;
            symbol: string;
            description: string;
            sellerFeeBasisPoints: number;
            collectionName: string;
            creators: Array<{
                __typename?: 'NftCreator';
                address: string;
                share: number;
            }>;
            mintAs: {
                __typename?: 'MintAs';
                kind: MintAsKind;
                params?: {
                    __typename?: 'MintAsParamsMplBubblegum';
                    merkleTree: string;
                } | null;
            };
        } | {
            __typename?: 'CharacterConfigWrapped';
            kind: string;
            criterias: Array<{
                __typename?: 'AssetCriteria';
                kind: AssetCriteriaKind;
                params?: string | null;
            }>;
        };
    }>;
};
export type FindCharactersQueryVariables = Exact<{
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    filters?: InputMaybe<CharactersFilter>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    wallets?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    mints?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    attributeHashes?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindCharactersQuery = {
    __typename?: 'Query';
    character: Array<{
        __typename?: 'Character';
        owner: string;
        equipments: Record<string, any>;
        leaf_idx: string;
        tree_id: string;
        address: string;
        asset?: any | null;
        source: {
            __typename?: 'CharacterSource';
            kind: CharacterSourceKind;
            params: {
                __typename?: 'Assembled';
                hash?: string | null;
                mint: string;
                uri: string;
                attributes?: Record<string, any> | null;
                assemblerConfig: string;
            } | {
                __typename?: 'Wrapped';
                mint: string;
                kind?: SourceKind | null;
                criteria: {
                    __typename?: 'AssetCriteria';
                    kind: AssetCriteriaKind;
                    params?: string | null;
                };
            };
        };
        proof?: {
            __typename?: 'Proof';
            leaf: string;
            leaf_index: string;
            node_index: string;
            maxDepth: number;
            proof: Array<string>;
            root: string;
            tree_id: string;
            canopy_depth: number;
        } | null;
        usedBy: {
            __typename?: 'CharacterUsedBy';
            kind: string;
            params?: {
                __typename?: 'UsedByCustom';
                user: string;
                data: any;
            } | {
                __typename?: 'UsedByEjected';
                mint: string;
            } | {
                __typename?: 'UsedByGuild';
                id: string;
                order: number;
                role: {
                    __typename?: 'GuildRole';
                    kind: string;
                };
            } | {
                __typename?: 'UsedByMission';
                missionId: string;
                participationId: string;
                endTime: number;
                rewards: Array<{
                    __typename?: 'EarnedRewards';
                    delta: number;
                    rewardIdx: number;
                    collected: boolean;
                }>;
            } | {
                __typename?: 'UsedByStaking';
                pool: string;
                staker: string;
                stakedAt: number;
                claimedAt: number;
            } | null;
        };
        cooldown: {
            __typename?: 'CharacterCooldown';
            ejection: number;
        };
    }>;
};
export type FetchCharacterHistoryQueryVariables = Exact<{
    addresses: Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input'];
    event?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;
export type FetchCharacterHistoryQuery = {
    __typename?: 'Query';
    characterHistory: Array<{
        __typename?: 'CharacterHistory';
        address: string;
        event: string;
        event_data: any;
        time: string;
    }>;
};
export type CreateCreateAssemblerConfigTransactionQueryVariables = Exact<{
    treeConfig?: InputMaybe<TreeSetupConfig>;
    ticker: Scalars['String']['input'];
    order?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    project: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateAssemblerConfigTransactionQuery = {
    __typename?: 'Query';
    createCreateAssemblerConfigTransaction: {
        __typename?: 'CreateAssemblerConfigTransactionResponse';
        assemblerConfig: string;
        treeAddress?: string | null;
        proofBytes?: number | null;
        space?: number | null;
        cost?: number | null;
        maxTreeCapacity?: number | null;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateAddCharacterTraitsTransactionsQueryVariables = Exact<{
    assemblerConfig: Scalars['String']['input'];
    traits: Array<CharacterTraitInput> | CharacterTraitInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateAddCharacterTraitsTransactionsQuery = {
    __typename?: 'Query';
    createAddCharacterTraitsTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateRemoveCharacterTraitsTransactionsQueryVariables = Exact<{
    assemblerConfig: Scalars['String']['input'];
    traitsAddresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateRemoveCharacterTraitsTransactionsQuery = {
    __typename?: 'Query';
    createRemoveCharacterTraitsTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateCreateCharacterModelTransactionQueryVariables = Exact<{
    config: CharacterConfigInput;
    project: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    mintAs?: InputMaybe<MintAsInput>;
    cooldown?: InputMaybe<CharacterCooldownInput>;
    equipableCriteria?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateCharacterModelTransactionQuery = {
    __typename?: 'Query';
    createCreateCharacterModelTransaction: {
        __typename?: 'CreateCharacterModelTransactionResponse';
        characterModel: string;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateCreateCharactersTreeTransactionQueryVariables = Exact<{
    treeConfig: TreeSetupConfig;
    project: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateCharactersTreeTransactionQuery = {
    __typename?: 'Query';
    createCreateCharactersTreeTransaction: {
        __typename?: 'TreeSetupResponse';
        treeAddress: string;
        proofBytes: number;
        space: number;
        cost?: number | null;
        maxTreeCapacity: number;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateAssembleCharacterTransactionQueryVariables = Exact<{
    uri?: InputMaybe<Scalars['String']['input']>;
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    project: Scalars['String']['input'];
    assemblerConfig: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    owner: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateAssembleCharacterTransactionQuery = {
    __typename?: 'Query';
    createAssembleCharacterTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateUpdateCharacterTraitsTransactionQueryVariables = Exact<{
    characterAddress: Scalars['String']['input'];
    uri?: InputMaybe<Scalars['String']['input']>;
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    project: Scalars['String']['input'];
    assemblerConfig: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateCharacterTraitsTransactionQuery = {
    __typename?: 'Query';
    createUpdateCharacterTraitsTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreatePopulateCharacterTransactionQueryVariables = Exact<{
    attributes?: InputMaybe<Scalars['VecMapGeneric']['input']>;
    project: Scalars['String']['input'];
    assemblerConfig?: InputMaybe<Scalars['String']['input']>;
    characterModel: Scalars['String']['input'];
    mint: Scalars['String']['input'];
    owner: Scalars['String']['input'];
    updateAuthority: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreatePopulateCharacterTransactionQuery = {
    __typename?: 'Query';
    createPopulateCharacterTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateWrapAssetsToCharacterTransactionsQueryVariables = Exact<{
    project: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    wallet: Scalars['String']['input'];
    mintList: Array<Scalars['String']['input']> | Scalars['String']['input'];
    libreplexDeployment?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateWrapAssetsToCharacterTransactionsQuery = {
    __typename?: 'Query';
    createWrapAssetsToCharacterTransactions: {
        __typename?: 'Transactions';
        transactions: Array<string>;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateUnwrapAssetsFromCharacterTransactionsQueryVariables = Exact<{
    project: Scalars['String']['input'];
    characterAddresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    wallet: Scalars['String']['input'];
    libreplexDeployment?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUnwrapAssetsFromCharacterTransactionsQuery = {
    __typename?: 'Query';
    createUnwrapAssetsFromCharacterTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateEquipResourceOnCharacterTransactionQueryVariables = Exact<{
    characterModel: Scalars['String']['input'];
    characterAddress: Scalars['String']['input'];
    resource: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateEquipResourceOnCharacterTransactionQuery = {
    __typename?: 'Query';
    createEquipResourceOnCharacterTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateDismountResourceOnCharacterTransactionQueryVariables = Exact<{
    characterModel: Scalars['String']['input'];
    characterAddress: Scalars['String']['input'];
    resource: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateDismountResourceOnCharacterTransactionQuery = {
    __typename?: 'Query';
    createDismountResourceOnCharacterTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateUseCharacterTransactionQueryVariables = Exact<{
    data?: InputMaybe<Scalars['JSON']['input']>;
    unUse?: InputMaybe<Scalars['Boolean']['input']>;
    character: Scalars['String']['input'];
    project: Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    user: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUseCharacterTransactionQuery = {
    __typename?: 'Query';
    createUseCharacterTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type FindStakingPoolsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    names?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;
export type FindStakingPoolsQuery = {
    __typename?: 'Query';
    stakingPools: Array<{
        __typename?: 'StakingPool';
        allowedMints: boolean;
        bump: number;
        characterModels: Array<string | null>;
        cooldownDuration?: string | null;
        resource: string;
        endTime?: string | null;
        key: string;
        maxRewardsDuration?: string | null;
        minStakeDuration?: string | null;
        name: string;
        project: string;
        resetStakeDuration: boolean;
        rewardsDuration: string;
        rewardsPerDuration: string;
        startTime?: string | null;
        totalStaked: string;
        address: string;
        lockType: {
            __typename?: 'LockType';
            kind?: string | null;
        };
    }>;
};
export type FindStakersQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    stakingPools?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    wallets?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindStakersQuery = {
    __typename?: 'Query';
    stakers: Array<{
        __typename?: 'Staker';
        bump: number;
        stakingPool: string;
        totalStaked: string;
        wallet: string;
    }>;
};
export type FindMultipliersQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    stakingPools?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindMultipliersQuery = {
    __typename?: 'Query';
    multipliers: Array<{
        __typename?: 'Multipliers';
        bump: number;
        decimals: number;
        address: string;
        stakingPool: string;
        collectionMultipliers: Array<{
            __typename?: 'Multiplier';
            value: string;
            multiplierType: {
                __typename?: 'MultiplierType';
                kind: string;
                params: {
                    __typename?: 'MultiplierTypeParamsCollection';
                    collection: string;
                } | {
                    __typename?: 'MultiplierTypeParamsCreator';
                    creator: string;
                } | {
                    __typename?: 'MultiplierTypeParamsNFTCount';
                    minCount: string;
                } | {
                    __typename?: 'MultiplierTypeParamsStakeDuration';
                    minDuration: string;
                };
            };
        }>;
        countMultipliers: Array<{
            __typename?: 'Multiplier';
            value: string;
            multiplierType: {
                __typename?: 'MultiplierType';
                kind: string;
                params: {
                    __typename?: 'MultiplierTypeParamsCollection';
                    collection: string;
                } | {
                    __typename?: 'MultiplierTypeParamsCreator';
                    creator: string;
                } | {
                    __typename?: 'MultiplierTypeParamsNFTCount';
                    minCount: string;
                } | {
                    __typename?: 'MultiplierTypeParamsStakeDuration';
                    minDuration: string;
                };
            };
        }>;
        creatorMultipliers: Array<{
            __typename?: 'Multiplier';
            value: string;
            multiplierType: {
                __typename?: 'MultiplierType';
                kind: string;
                params: {
                    __typename?: 'MultiplierTypeParamsCollection';
                    collection: string;
                } | {
                    __typename?: 'MultiplierTypeParamsCreator';
                    creator: string;
                } | {
                    __typename?: 'MultiplierTypeParamsNFTCount';
                    minCount: string;
                } | {
                    __typename?: 'MultiplierTypeParamsStakeDuration';
                    minDuration: string;
                };
            };
        }>;
        durationMultipliers: Array<{
            __typename?: 'Multiplier';
            value: string;
            multiplierType: {
                __typename?: 'MultiplierType';
                kind: string;
                params: {
                    __typename?: 'MultiplierTypeParamsCollection';
                    collection: string;
                } | {
                    __typename?: 'MultiplierTypeParamsCreator';
                    creator: string;
                } | {
                    __typename?: 'MultiplierTypeParamsNFTCount';
                    minCount: string;
                } | {
                    __typename?: 'MultiplierTypeParamsStakeDuration';
                    minDuration: string;
                };
            };
        }>;
    }>;
};
export type CreateCreateStakingPoolTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    resource: Scalars['String']['input'];
    metadata: CreateStakingPoolMetadataInput;
    authority: Scalars['String']['input'];
    multiplier?: InputMaybe<InitStakingMultiplierMetadataInput>;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateStakingPoolTransactionQuery = {
    __typename?: 'Query';
    createCreateStakingPoolTransaction: {
        __typename?: 'CreateCreateStakingPoolTransactionResponse';
        stakingPoolAddress: string;
        multipliersAddress?: string | null;
        transactions: {
            __typename?: 'Transactions';
            transactions: Array<string>;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateUpdateStakingPoolTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    stakingPool: Scalars['String']['input'];
    metadata?: InputMaybe<UpdateStakingPoolMetadataInput>;
    authority: Scalars['String']['input'];
    characterModel?: InputMaybe<Scalars['String']['input']>;
    resource?: InputMaybe<Scalars['String']['input']>;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateStakingPoolTransactionQuery = {
    __typename?: 'Query';
    createUpdateStakingPoolTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateInitMultipliersTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    stakingPool: Scalars['String']['input'];
    decimals: Scalars['Int']['input'];
    multipliers: Array<InputMaybe<AddMultiplierMetadataInput>> | InputMaybe<AddMultiplierMetadataInput>;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateInitMultipliersTransactionQuery = {
    __typename?: 'Query';
    createInitMultipliersTransaction: {
        __typename?: 'CreateInitMultipliersTransactionResponse';
        multipliersAddress: string;
        tx: {
            __typename?: 'Transaction';
            transaction: string;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateAddMultiplierTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    multiplier: Scalars['String']['input'];
    metadata: AddMultiplierMetadataInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateAddMultiplierTransactionQuery = {
    __typename?: 'Query';
    createAddMultiplierTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateStakeCharactersTransactionsQueryVariables = Exact<{
    characterAddresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    stakingPool: Scalars['String']['input'];
    project: Scalars['String']['input'];
    feePayer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateStakeCharactersTransactionsQuery = {
    __typename?: 'Query';
    createStakeCharactersTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type FindSplStakingPoolsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    names?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    stakeTokenMints?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindSplStakingPoolsQuery = {
    __typename?: 'Query';
    splStakingPools: Array<{
        __typename?: 'SplStakingPool';
        address: string;
        bump: number;
        nonce?: number | null;
        endTime?: string | null;
        maxStakeDurationSecs?: string | null;
        minStakeDurationSecs?: string | null;
        name: string;
        project: string;
        stake_token_mint: string;
        startTime?: string | null;
        totalStakedAmount: string;
        merkleTrees: {
            __typename?: 'ControlledMerkleTrees';
            active: number;
            merkle_trees: Array<string>;
            schema: any;
        };
        multipliers: Array<{
            __typename?: 'SplMultiplier';
            value: string;
            multiplierType: {
                __typename?: 'SplMultiplierType';
                kind: string;
                params: {
                    __typename: 'SplMultiplierTypeParamsStakeAmount';
                    minAmount: string;
                } | {
                    __typename: 'SplMultiplierTypeParamsStakeDuration';
                    minDuration: string;
                };
            };
        }>;
        rewardConfig: {
            __typename?: 'SplRewardConfig';
            kind: string;
            params?: {
                __typename?: 'SplRewardConfigParamsApy';
                rewardTokenMint?: string | null;
                rewardVault?: string | null;
                rewardsDuration: string;
                rewardsPerDuration: string;
                totalRewardAmount: string;
            } | {
                __typename?: 'SplRewardConfigParamsNotSet';
            } | {
                __typename: 'SplRewardConfigParamsStakeWeight';
                pools: Array<{
                    __typename?: 'SplStakeWeightConfig';
                    weight: number;
                }>;
            } | null;
        };
    }>;
};
export type FindSplStakingRecipientsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    stakers?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    projects?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    splStakingPools?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
}>;
export type FindSplStakingRecipientsQuery = {
    __typename?: 'Query';
    splStakingRecipients: Array<{
        __typename?: 'StakingRecipient';
        address: string;
        leaf_idx: string;
        lokedTill: string;
        multiplier: number;
        stakeStartTime: string;
        staker: string;
        stakedAmount: string;
        tree_id: string;
        proof?: {
            __typename?: 'Proof';
            canopy_depth: number;
            leaf: string;
            leaf_index: string;
            maxDepth: number;
            node_index: string;
            proof: Array<string>;
            root: string;
            tree_id: string;
        } | null;
        rewardsClaimed: {
            __typename?: 'StakerClaimed';
            kind: string;
            params?: {
                __typename: 'StakerClaimedParamsApy';
                lastRewardTime: string;
            } | {
                __typename?: 'StakerClaimedParamsNone';
            } | {
                __typename: 'StakerClaimedParamsStakeWeight';
                amounts: Array<string | null>;
            } | null;
        };
    }>;
};
export type CreateCreateSplStakingPoolTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    stakeTokenMint: Scalars['String']['input'];
    metadata: CreateSplStakingPoolMetadataInput;
    multipliers?: InputMaybe<Array<AddSplMultiplierMetadataInput> | AddSplMultiplierMetadataInput>;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateSplStakingPoolTransactionQuery = {
    __typename?: 'Query';
    createCreateSplStakingPoolTransaction: {
        __typename?: 'CreateCreateSplStakingPoolTransactionResponse';
        splStakingPoolAddress: string;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateUpdateSplStakingPoolTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    metadata: UpdateSplStakingPoolMetadataInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateSplStakingPoolTransactionQuery = {
    __typename?: 'Query';
    createUpdateSplStakingPoolTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateCreateNewSplStakingPoolTreeTransactionQueryVariables = Exact<{
    treeConfig: TreeSetupConfig;
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateNewSplStakingPoolTreeTransactionQuery = {
    __typename?: 'Query';
    createCreateNewSplStakingPoolTreeTransaction: {
        __typename?: 'TreeSetupResponse';
        treeAddress: string;
        proofBytes: number;
        space: number;
        cost?: number | null;
        maxTreeCapacity: number;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateAddRemoveSplMultipliersTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    add?: InputMaybe<Array<AddSplMultiplierMetadataInput> | AddSplMultiplierMetadataInput>;
    remove?: InputMaybe<Array<Scalars['Int']['input']> | Scalars['Int']['input']>;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateAddRemoveSplMultipliersTransactionQuery = {
    __typename?: 'Query';
    createAddRemoveSplMultipliersTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateSplRewardPoolTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    rewardTokenMint: Scalars['String']['input'];
    rewardConfig: CreateSplRewardPoolArgsInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateSplRewardPoolTransactionQuery = {
    __typename?: 'Query';
    createSplRewardPoolTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateAddRemoveRewardsFromRewardPoolTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    rewardTokenMint: Scalars['String']['input'];
    action: AddRemoveRewardsFromRewardPoolActionInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateAddRemoveRewardsFromRewardPoolTransactionQuery = {
    __typename?: 'Query';
    createAddRemoveRewardsFromRewardPoolTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateStakeSplTokensTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    lockPeriodSecs: Scalars['BigInt']['input'];
    staker: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateStakeSplTokensTransactionQuery = {
    __typename?: 'Query';
    createStakeSplTokensTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateClaimSplRewardsTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    staker: Scalars['String']['input'];
    stakingReciept: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateClaimSplRewardsTransactionQuery = {
    __typename?: 'Query';
    createClaimSplRewardsTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateUnstakeSplTokensTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    splStakingPool: Scalars['String']['input'];
    staker: Scalars['String']['input'];
    stakingReciept: Scalars['String']['input'];
    payer: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUnstakeSplTokensTransactionQuery = {
    __typename?: 'Query';
    createUnstakeSplTokensTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateClaimStakingRewardsTransactionsQueryVariables = Exact<{
    characterAddresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    feePayer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateClaimStakingRewardsTransactionsQuery = {
    __typename?: 'Query';
    createClaimStakingRewardsTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateUnstakeCharactersTransactionsQueryVariables = Exact<{
    characterAddresses: Array<Scalars['String']['input']> | Scalars['String']['input'];
    characterModel: Scalars['String']['input'];
    feePayer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUnstakeCharactersTransactionsQuery = {
    __typename?: 'Query';
    createUnstakeCharactersTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type FindMissionsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    missionPools?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindMissionsQuery = {
    __typename?: 'Query';
    mission: Array<{
        __typename?: 'Mission';
        project: string;
        address: string;
        program_id: string;
        discriminator: string;
        bump: number;
        missionPool: string;
        name: string;
        minXp: string;
        cost: {
            __typename?: 'MissionCost';
            amount: string;
            resource_address: string;
        };
        requirement: {
            __typename?: 'TimeRequirement';
            kind: string;
            params: {
                __typename?: 'TimeRequirementParams';
                duration: string;
            };
        };
        rewards: Array<{
            __typename?: 'Reward';
            min: string;
            max: string;
            rewardType?: {
                __typename?: 'ResourceRewardType';
                kind: string;
                params: {
                    __typename?: 'ResourceRewardTypeParams';
                    address: string;
                };
            } | {
                __typename?: 'XpRewardType';
                kind: string;
            } | null;
        } | null>;
    }>;
};
export type FindMissionPoolsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    project?: InputMaybe<Scalars['Pubkey']['input']>;
}>;
export type FindMissionPoolsQuery = {
    __typename?: 'Query';
    missionPool: Array<{
        __typename?: 'MissionPool';
        address: string;
        program_id: string;
        discriminator: string;
        bump: number;
        project: string;
        name: string;
        factionsMerkleRoot: string;
        randomizerRound: number;
        characterModels: Array<string | null>;
        guildKits: Array<number | null>;
    }>;
};
export type CreateCreateMissionPoolTransactionQueryVariables = Exact<{
    data: NewMissionPoolData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateMissionPoolTransactionQuery = {
    __typename?: 'Query';
    createCreateMissionPoolTransaction: {
        __typename?: 'CreateCreateMissionPoolTransactionResponse';
        missionPoolAddress: string;
        tx: {
            __typename?: 'Transaction';
            transaction: string;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateUpdateMissionPoolTransactionQueryVariables = Exact<{
    data: UpdateMissionPoolData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateMissionPoolTransactionQuery = {
    __typename?: 'Query';
    createUpdateMissionPoolTransaction: {
        __typename?: 'CreateUpdateMissionPoolTransactionResponse';
        tx: {
            __typename?: 'Transaction';
            transaction: string;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateCreateMissionTransactionQueryVariables = Exact<{
    data: NewMissionData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateMissionTransactionQuery = {
    __typename?: 'Query';
    createCreateMissionTransaction: {
        __typename?: 'CreateCreateMissionTransactionResponse';
        missionAddress: string;
        tx: {
            __typename?: 'Transaction';
            transaction: string;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateUpdateMissionTransactionQueryVariables = Exact<{
    missionAddress: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    params: UpdateMissionInput;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateMissionTransactionQuery = {
    __typename?: 'Query';
    createUpdateMissionTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateSendCharactersOnMissionTransactionQueryVariables = Exact<{
    data: ParticipateOnMissionData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateSendCharactersOnMissionTransactionQuery = {
    __typename?: 'Query';
    createSendCharactersOnMissionTransaction: {
        __typename?: 'Transactions';
        transactions: Array<string>;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateRecallCharactersTransactionQueryVariables = Exact<{
    data: RecallFromMissionData;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateRecallCharactersTransactionQuery = {
    __typename?: 'Query';
    createRecallCharactersTransaction: {
        __typename?: 'Transactions';
        transactions: Array<string>;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type FindResourcesQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    mints?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindResourcesQuery = {
    __typename?: 'Query';
    resources: Array<{
        __typename?: 'Resource';
        address: string;
        bump: number;
        mint: string;
        project: string;
        tags: Array<string>;
        kind: {
            __typename?: 'ResourceKind';
            kind: string;
            params?: {
                __typename: 'ResourceKindParamsHplFungible';
                decimals: number;
            } | {
                __typename: 'ResourceKindParamsHplNonFungible';
                characteristics: Array<string | null>;
            } | {
                __typename: 'ResourceKindParamsWrappedFungible';
                decimals: number;
                custody: {
                    __typename?: 'ResourceCustody';
                    kind: ResourceCustodyEnum;
                    params?: {
                        __typename?: 'ResourceCustodyParams';
                        burnerDestination?: string | null;
                    } | null;
                };
            } | {
                __typename: 'ResourceKindParamsWrappedMplCore';
                characteristics: Array<string | null>;
            } | null;
        };
        storage: {
            __typename?: 'ResourceStorage';
            kind: ResourceStorageEnum;
            params?: {
                __typename?: 'ResourceStorageParams';
                promiseSupply: string;
                merkle_trees: {
                    __typename?: 'ControlledMerkleTrees';
                    active: number;
                    merkle_trees: Array<string>;
                    schema: any;
                };
            } | null;
        };
    }>;
};
export type FindResourcesBalanceQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    projects?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    mints?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    wallets: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;
export type FindResourcesBalanceQuery = {
    __typename?: 'Query';
    resourcesBalance: Array<{
        __typename?: 'ResourceBalance';
        address: string;
        amount: string;
        mint: string;
        wallet?: string | null;
        resourceStorage: ResourceStorageEnum;
    }>;
};
export type FindFaucetsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
    resources?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindFaucetsQuery = {
    __typename?: 'Query';
    faucets: Array<{
        __typename?: 'Faucet';
        resource: string;
        repeatInterval: string;
        project: string;
        amount: string;
        lastClaimed: string;
        address: string;
    }>;
};
export type FindRecipesQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    projects?: InputMaybe<Array<Scalars['Pubkey']['input']> | Scalars['Pubkey']['input']>;
}>;
export type FindRecipesQuery = {
    __typename?: 'Query';
    recipes: Array<{
        __typename?: 'Recipe';
        address: string;
        bump: number;
        key: string;
        project: string;
        xp: string;
        ingredients: Array<{
            __typename?: 'Ingredient';
            amount: string;
            resourceAddress: string;
        }>;
        meal: {
            __typename?: 'Meal';
            amount: string;
            resourceAddress: string;
        };
    }>;
};
export type FindHoldingsQueryVariables = Exact<{
    addresses?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    holders?: InputMaybe<Array<InputMaybe<Scalars['Pubkey']['input']>> | InputMaybe<Scalars['Pubkey']['input']>>;
    trees?: InputMaybe<Array<Scalars['Bytes']['input']> | Scalars['Bytes']['input']>;
    includeProof?: InputMaybe<Scalars['Boolean']['input']>;
}>;
export type FindHoldingsQuery = {
    __typename?: 'Query';
    holdings: Array<{
        __typename?: 'Holding';
        address: string;
        balance: string;
        characteristics?: Record<string, any> | null;
        holder: string;
        leaf_idx: string;
        tree_id: string;
        proof?: {
            __typename?: 'Proof';
            canopy_depth: number;
            leaf: string;
            leaf_index: string;
            maxDepth: number;
            node_index: string;
            proof: Array<string>;
            root: string;
            tree_id: string;
        } | null;
    }>;
};
export type CreateCreateNewResourceTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    params: InitResourceInput;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateNewResourceTransactionQuery = {
    __typename?: 'Query';
    createCreateNewResourceTransaction: {
        __typename?: 'CreateInitResourceTransactionResponse';
        resource: string;
        tx: {
            __typename?: 'Transaction';
            transaction: string;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateImportFungibleResourceTransactionQueryVariables = Exact<{
    params: ImportResourceInput;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateImportFungibleResourceTransactionQuery = {
    __typename?: 'Query';
    createImportFungibleResourceTransaction: {
        __typename?: 'CreateInitResourceTransactionResponse';
        resource: string;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateExportFungibleResourceTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateExportFungibleResourceTransactionQuery = {
    __typename?: 'Query';
    createExportFungibleResourceTransaction: {
        __typename?: 'Transaction';
        blockhash: string;
        lastValidBlockHeight: number;
        transaction: string;
    };
};
export type CreateCreateNewResourceTreeTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    resource: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    treeConfig: TreeSetupConfig;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateNewResourceTreeTransactionQuery = {
    __typename?: 'Query';
    createCreateNewResourceTreeTransaction: {
        __typename?: 'TreeSetupResponse';
        treeAddress: string;
        proofBytes: number;
        space: number;
        cost?: number | null;
        maxTreeCapacity: number;
        tx: {
            __typename?: 'Transaction';
            blockhash: string;
            lastValidBlockHeight: number;
            transaction: string;
        };
    };
};
export type CreateMintResourceTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    owner: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateMintResourceTransactionQuery = {
    __typename?: 'Query';
    createMintResourceTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateBurnResourceTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    owner?: InputMaybe<Scalars['String']['input']>;
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateBurnResourceTransactionQuery = {
    __typename?: 'Query';
    createBurnResourceTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateTransferResourceTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    owner: Scalars['String']['input'];
    recipient: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateTransferResourceTransactionQuery = {
    __typename?: 'Query';
    createTransferResourceTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateCreateWrapHoldingTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateWrapHoldingTransactionQuery = {
    __typename?: 'Query';
    createCreateWrapHoldingTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateCreateUnwrapHoldingTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    amount: Scalars['BigInt']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateCreateUnwrapHoldingTransactionQuery = {
    __typename?: 'Query';
    createCreateUnwrapHoldingTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateInitializeFaucetTransactionQueryVariables = Exact<{
    resource: Scalars['String']['input'];
    amount: Scalars['Int']['input'];
    repeatInterval: Scalars['Int']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateInitializeFaucetTransactionQuery = {
    __typename?: 'Query';
    createInitializeFaucetTransaction: {
        __typename?: 'CreateInitializeFaucetTransactionResponse';
        faucet: string;
        tx: {
            __typename?: 'Transaction';
            transaction: string;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateClaimFaucetTransactionQueryVariables = Exact<{
    faucet: Scalars['String']['input'];
    owner: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateClaimFaucetTransactionQuery = {
    __typename?: 'Query';
    createClaimFaucetTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateInitializeRecipeTransactionQueryVariables = Exact<{
    project: Scalars['String']['input'];
    xp: Scalars['BigInt']['input'];
    ingredients: Array<IngredientsInput> | IngredientsInput;
    meal: MealInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateInitializeRecipeTransactionQuery = {
    __typename?: 'Query';
    createInitializeRecipeTransaction: {
        __typename?: 'CreateInitializeRecipeTransactionResponse';
        recipe: string;
        transactions: {
            __typename?: 'Transactions';
            transactions: Array<string>;
            blockhash: string;
            lastValidBlockHeight: number;
        };
    };
};
export type CreateAddIngredientsTransactionQueryVariables = Exact<{
    recipe: Scalars['String']['input'];
    ingredients: Array<IngredientsInput> | IngredientsInput;
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateAddIngredientsTransactionQuery = {
    __typename?: 'Query';
    createAddIngredientsTransaction: {
        __typename?: 'Transactions';
        transactions: Array<string>;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateRemoveIngredientsTransactionQueryVariables = Exact<{
    recipe: Scalars['String']['input'];
    ingredients: Array<Scalars['String']['input']> | Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateRemoveIngredientsTransactionQuery = {
    __typename?: 'Query';
    createRemoveIngredientsTransaction: {
        __typename?: 'Transactions';
        transactions: Array<string>;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateInitCookingProcessTransactionsQueryVariables = Exact<{
    recipe: Scalars['String']['input'];
    authority: Scalars['String']['input'];
    payer?: InputMaybe<Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;
export type CreateInitCookingProcessTransactionsQuery = {
    __typename?: 'Query';
    createInitCookingProcessTransactions: {
        __typename?: 'Transactions';
        blockhash: string;
        lastValidBlockHeight: number;
        transactions: Array<string>;
    };
};
export type CreateInitializeBadgeCriteriaTransactionQueryVariables = Exact<{
    args: CreateBadgeCriteriaInput;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateInitializeBadgeCriteriaTransactionQuery = {
    __typename?: 'Query';
    createInitializeBadgeCriteriaTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateClaimBadgeCriteriaTransactionQueryVariables = Exact<{
    args: ClaimBadgeCriteriaInput;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateClaimBadgeCriteriaTransactionQuery = {
    __typename?: 'Query';
    createClaimBadgeCriteriaTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export type CreateUpdateBadgeCriteriaTransactionQueryVariables = Exact<{
    args: UpdateBadgeCriteriaInput;
    lutAddresses?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
    computeUnitPrice?: InputMaybe<Scalars['Int']['input']>;
}>;
export type CreateUpdateBadgeCriteriaTransactionQuery = {
    __typename?: 'Query';
    createUpdateBadgeCriteriaTransaction: {
        __typename?: 'Transaction';
        transaction: string;
        blockhash: string;
        lastValidBlockHeight: number;
    };
};
export declare const FindCompressedAccountsDocument: any;
export declare const FetchProofsDocument: any;
export declare const FindAccountsDocument: any;
export declare const SendTransactionBundlesDocument: any;
export declare const SignWithShadowSignerAndSendTransactionBundlesDocument: any;
export declare const SendBulkTransactionsDocument: any;
export declare const SignWithShadowSignerAndSendBulkTransactionsDocument: any;
export declare const AuthRequestDocument: any;
export declare const AuthConfirmDocument: any;
export declare const CreateTransferAssetsTransactionsDocument: any;
export declare const CreateBurnAssetsTransactionsDocument: any;
export declare const FindGlobalDocument: any;
export declare const FindProjectsDocument: any;
export declare const FindDelegateAuthorityDocument: any;
export declare const FindUsersDocument: any;
export declare const FindProfilesDocument: any;
export declare const CreateNewUserTransactionDocument: any;
export declare const CreateNewUserBulkTransactionDocument: any;
export declare const CreateUpdateUserTransactionDocument: any;
export declare const CreateCreateProjectTransactionDocument: any;
export declare const CreateChangeProjectDriverTransactionDocument: any;
export declare const CreateCreateDelegateAuthorityTransactionDocument: any;
export declare const CreateModifyDelegationTransactionDocument: any;
export declare const CreateCreateProfilesTreeTransactionDocument: any;
export declare const CreateNewProfileTransactionDocument: any;
export declare const CreateUpdateProfileTransactionDocument: any;
export declare const CreateUpdatePlatformDataTransactionDocument: any;
export declare const CreateNewUserWithProfileTransactionDocument: any;
export declare const FindAssemblerConfigDocument: any;
export declare const FindCharacterTraitsDocument: any;
export declare const FindCharacterModelsDocument: any;
export declare const FindCharactersDocument: any;
export declare const FetchCharacterHistoryDocument: any;
export declare const CreateCreateAssemblerConfigTransactionDocument: any;
export declare const CreateAddCharacterTraitsTransactionsDocument: any;
export declare const CreateRemoveCharacterTraitsTransactionsDocument: any;
export declare const CreateCreateCharacterModelTransactionDocument: any;
export declare const CreateCreateCharactersTreeTransactionDocument: any;
export declare const CreateAssembleCharacterTransactionDocument: any;
export declare const CreateUpdateCharacterTraitsTransactionDocument: any;
export declare const CreatePopulateCharacterTransactionDocument: any;
export declare const CreateWrapAssetsToCharacterTransactionsDocument: any;
export declare const CreateUnwrapAssetsFromCharacterTransactionsDocument: any;
export declare const CreateEquipResourceOnCharacterTransactionDocument: any;
export declare const CreateDismountResourceOnCharacterTransactionDocument: any;
export declare const CreateUseCharacterTransactionDocument: any;
export declare const FindStakingPoolsDocument: any;
export declare const FindStakersDocument: any;
export declare const FindMultipliersDocument: any;
export declare const CreateCreateStakingPoolTransactionDocument: any;
export declare const CreateUpdateStakingPoolTransactionDocument: any;
export declare const CreateInitMultipliersTransactionDocument: any;
export declare const CreateAddMultiplierTransactionDocument: any;
export declare const CreateStakeCharactersTransactionsDocument: any;
export declare const FindSplStakingPoolsDocument: any;
export declare const FindSplStakingRecipientsDocument: any;
export declare const CreateCreateSplStakingPoolTransactionDocument: any;
export declare const CreateUpdateSplStakingPoolTransactionDocument: any;
export declare const CreateCreateNewSplStakingPoolTreeTransactionDocument: any;
export declare const CreateAddRemoveSplMultipliersTransactionDocument: any;
export declare const CreateSplRewardPoolTransactionDocument: any;
export declare const CreateAddRemoveRewardsFromRewardPoolTransactionDocument: any;
export declare const CreateStakeSplTokensTransactionDocument: any;
export declare const CreateClaimSplRewardsTransactionDocument: any;
export declare const CreateUnstakeSplTokensTransactionDocument: any;
export declare const CreateClaimStakingRewardsTransactionsDocument: any;
export declare const CreateUnstakeCharactersTransactionsDocument: any;
export declare const FindMissionsDocument: any;
export declare const FindMissionPoolsDocument: any;
export declare const CreateCreateMissionPoolTransactionDocument: any;
export declare const CreateUpdateMissionPoolTransactionDocument: any;
export declare const CreateCreateMissionTransactionDocument: any;
export declare const CreateUpdateMissionTransactionDocument: any;
export declare const CreateSendCharactersOnMissionTransactionDocument: any;
export declare const CreateRecallCharactersTransactionDocument: any;
export declare const FindResourcesDocument: any;
export declare const FindResourcesBalanceDocument: any;
export declare const FindFaucetsDocument: any;
export declare const FindRecipesDocument: any;
export declare const FindHoldingsDocument: any;
export declare const CreateCreateNewResourceTransactionDocument: any;
export declare const CreateImportFungibleResourceTransactionDocument: any;
export declare const CreateExportFungibleResourceTransactionDocument: any;
export declare const CreateCreateNewResourceTreeTransactionDocument: any;
export declare const CreateMintResourceTransactionDocument: any;
export declare const CreateBurnResourceTransactionDocument: any;
export declare const CreateTransferResourceTransactionDocument: any;
export declare const CreateCreateWrapHoldingTransactionDocument: any;
export declare const CreateCreateUnwrapHoldingTransactionDocument: any;
export declare const CreateInitializeFaucetTransactionDocument: any;
export declare const CreateClaimFaucetTransactionDocument: any;
export declare const CreateInitializeRecipeTransactionDocument: any;
export declare const CreateAddIngredientsTransactionDocument: any;
export declare const CreateRemoveIngredientsTransactionDocument: any;
export declare const CreateInitCookingProcessTransactionsDocument: any;
export declare const CreateInitializeBadgeCriteriaTransactionDocument: any;
export declare const CreateClaimBadgeCriteriaTransactionDocument: any;
export declare const CreateUpdateBadgeCriteriaTransactionDocument: any;
export type Requester<C = {}> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>;
export declare function getSdk<C>(requester: Requester<C>): {
    findCompressedAccounts(variables: FindCompressedAccountsQueryVariables, options?: C): Promise<FindCompressedAccountsQuery>;
    fetchProofs(variables: FetchProofsQueryVariables, options?: C): Promise<FetchProofsQuery>;
    findAccounts(variables: FindAccountsQueryVariables, options?: C): Promise<FindAccountsQuery>;
    sendTransactionBundles(variables: SendTransactionBundlesQueryVariables, options?: C): Promise<SendTransactionBundlesQuery>;
    signWithShadowSignerAndSendTransactionBundles(variables: SignWithShadowSignerAndSendTransactionBundlesQueryVariables, options?: C): Promise<SignWithShadowSignerAndSendTransactionBundlesQuery>;
    sendBulkTransactions(variables: SendBulkTransactionsQueryVariables, options?: C): Promise<SendBulkTransactionsQuery>;
    signWithShadowSignerAndSendBulkTransactions(variables: SignWithShadowSignerAndSendBulkTransactionsQueryVariables, options?: C): Promise<SignWithShadowSignerAndSendBulkTransactionsQuery>;
    authRequest(variables: AuthRequestQueryVariables, options?: C): Promise<AuthRequestQuery>;
    authConfirm(variables: AuthConfirmQueryVariables, options?: C): Promise<AuthConfirmQuery>;
    createTransferAssetsTransactions(variables: CreateTransferAssetsTransactionsQueryVariables, options?: C): Promise<CreateTransferAssetsTransactionsQuery>;
    createBurnAssetsTransactions(variables: CreateBurnAssetsTransactionsQueryVariables, options?: C): Promise<CreateBurnAssetsTransactionsQuery>;
    findGlobal(variables?: FindGlobalQueryVariables, options?: C): Promise<FindGlobalQuery>;
    findProjects(variables?: FindProjectsQueryVariables, options?: C): Promise<FindProjectsQuery>;
    findDelegateAuthority(variables?: FindDelegateAuthorityQueryVariables, options?: C): Promise<FindDelegateAuthorityQuery>;
    findUsers(variables?: FindUsersQueryVariables, options?: C): Promise<FindUsersQuery>;
    findProfiles(variables?: FindProfilesQueryVariables, options?: C): Promise<FindProfilesQuery>;
    createNewUserTransaction(variables: CreateNewUserTransactionQueryVariables, options?: C): Promise<CreateNewUserTransactionQuery>;
    createNewUserBulkTransaction(variables: CreateNewUserBulkTransactionQueryVariables, options?: C): Promise<CreateNewUserBulkTransactionQuery>;
    createUpdateUserTransaction(variables: CreateUpdateUserTransactionQueryVariables, options?: C): Promise<CreateUpdateUserTransactionQuery>;
    createCreateProjectTransaction(variables: CreateCreateProjectTransactionQueryVariables, options?: C): Promise<CreateCreateProjectTransactionQuery>;
    createChangeProjectDriverTransaction(variables: CreateChangeProjectDriverTransactionQueryVariables, options?: C): Promise<CreateChangeProjectDriverTransactionQuery>;
    createCreateDelegateAuthorityTransaction(variables: CreateCreateDelegateAuthorityTransactionQueryVariables, options?: C): Promise<CreateCreateDelegateAuthorityTransactionQuery>;
    createModifyDelegationTransaction(variables: CreateModifyDelegationTransactionQueryVariables, options?: C): Promise<CreateModifyDelegationTransactionQuery>;
    createCreateProfilesTreeTransaction(variables: CreateCreateProfilesTreeTransactionQueryVariables, options?: C): Promise<CreateCreateProfilesTreeTransactionQuery>;
    createNewProfileTransaction(variables: CreateNewProfileTransactionQueryVariables, options?: C): Promise<CreateNewProfileTransactionQuery>;
    createUpdateProfileTransaction(variables: CreateUpdateProfileTransactionQueryVariables, options?: C): Promise<CreateUpdateProfileTransactionQuery>;
    createUpdatePlatformDataTransaction(variables: CreateUpdatePlatformDataTransactionQueryVariables, options?: C): Promise<CreateUpdatePlatformDataTransactionQuery>;
    createNewUserWithProfileTransaction(variables: CreateNewUserWithProfileTransactionQueryVariables, options?: C): Promise<CreateNewUserWithProfileTransactionQuery>;
    findAssemblerConfig(variables?: FindAssemblerConfigQueryVariables, options?: C): Promise<FindAssemblerConfigQuery>;
    findCharacterTraits(variables?: FindCharacterTraitsQueryVariables, options?: C): Promise<FindCharacterTraitsQuery>;
    findCharacterModels(variables?: FindCharacterModelsQueryVariables, options?: C): Promise<FindCharacterModelsQuery>;
    findCharacters(variables?: FindCharactersQueryVariables, options?: C): Promise<FindCharactersQuery>;
    fetchCharacterHistory(variables: FetchCharacterHistoryQueryVariables, options?: C): Promise<FetchCharacterHistoryQuery>;
    createCreateAssemblerConfigTransaction(variables: CreateCreateAssemblerConfigTransactionQueryVariables, options?: C): Promise<CreateCreateAssemblerConfigTransactionQuery>;
    createAddCharacterTraitsTransactions(variables: CreateAddCharacterTraitsTransactionsQueryVariables, options?: C): Promise<CreateAddCharacterTraitsTransactionsQuery>;
    createRemoveCharacterTraitsTransactions(variables: CreateRemoveCharacterTraitsTransactionsQueryVariables, options?: C): Promise<CreateRemoveCharacterTraitsTransactionsQuery>;
    createCreateCharacterModelTransaction(variables: CreateCreateCharacterModelTransactionQueryVariables, options?: C): Promise<CreateCreateCharacterModelTransactionQuery>;
    createCreateCharactersTreeTransaction(variables: CreateCreateCharactersTreeTransactionQueryVariables, options?: C): Promise<CreateCreateCharactersTreeTransactionQuery>;
    createAssembleCharacterTransaction(variables: CreateAssembleCharacterTransactionQueryVariables, options?: C): Promise<CreateAssembleCharacterTransactionQuery>;
    createUpdateCharacterTraitsTransaction(variables: CreateUpdateCharacterTraitsTransactionQueryVariables, options?: C): Promise<CreateUpdateCharacterTraitsTransactionQuery>;
    createPopulateCharacterTransaction(variables: CreatePopulateCharacterTransactionQueryVariables, options?: C): Promise<CreatePopulateCharacterTransactionQuery>;
    createWrapAssetsToCharacterTransactions(variables: CreateWrapAssetsToCharacterTransactionsQueryVariables, options?: C): Promise<CreateWrapAssetsToCharacterTransactionsQuery>;
    createUnwrapAssetsFromCharacterTransactions(variables: CreateUnwrapAssetsFromCharacterTransactionsQueryVariables, options?: C): Promise<CreateUnwrapAssetsFromCharacterTransactionsQuery>;
    createEquipResourceOnCharacterTransaction(variables: CreateEquipResourceOnCharacterTransactionQueryVariables, options?: C): Promise<CreateEquipResourceOnCharacterTransactionQuery>;
    createDismountResourceOnCharacterTransaction(variables: CreateDismountResourceOnCharacterTransactionQueryVariables, options?: C): Promise<CreateDismountResourceOnCharacterTransactionQuery>;
    createUseCharacterTransaction(variables: CreateUseCharacterTransactionQueryVariables, options?: C): Promise<CreateUseCharacterTransactionQuery>;
    findStakingPools(variables?: FindStakingPoolsQueryVariables, options?: C): Promise<FindStakingPoolsQuery>;
    findStakers(variables?: FindStakersQueryVariables, options?: C): Promise<FindStakersQuery>;
    findMultipliers(variables?: FindMultipliersQueryVariables, options?: C): Promise<FindMultipliersQuery>;
    createCreateStakingPoolTransaction(variables: CreateCreateStakingPoolTransactionQueryVariables, options?: C): Promise<CreateCreateStakingPoolTransactionQuery>;
    createUpdateStakingPoolTransaction(variables: CreateUpdateStakingPoolTransactionQueryVariables, options?: C): Promise<CreateUpdateStakingPoolTransactionQuery>;
    createInitMultipliersTransaction(variables: CreateInitMultipliersTransactionQueryVariables, options?: C): Promise<CreateInitMultipliersTransactionQuery>;
    createAddMultiplierTransaction(variables: CreateAddMultiplierTransactionQueryVariables, options?: C): Promise<CreateAddMultiplierTransactionQuery>;
    createStakeCharactersTransactions(variables: CreateStakeCharactersTransactionsQueryVariables, options?: C): Promise<CreateStakeCharactersTransactionsQuery>;
    findSplStakingPools(variables?: FindSplStakingPoolsQueryVariables, options?: C): Promise<FindSplStakingPoolsQuery>;
    findSplStakingRecipients(variables?: FindSplStakingRecipientsQueryVariables, options?: C): Promise<FindSplStakingRecipientsQuery>;
    createCreateSplStakingPoolTransaction(variables: CreateCreateSplStakingPoolTransactionQueryVariables, options?: C): Promise<CreateCreateSplStakingPoolTransactionQuery>;
    createUpdateSplStakingPoolTransaction(variables: CreateUpdateSplStakingPoolTransactionQueryVariables, options?: C): Promise<CreateUpdateSplStakingPoolTransactionQuery>;
    createCreateNewSplStakingPoolTreeTransaction(variables: CreateCreateNewSplStakingPoolTreeTransactionQueryVariables, options?: C): Promise<CreateCreateNewSplStakingPoolTreeTransactionQuery>;
    createAddRemoveSplMultipliersTransaction(variables: CreateAddRemoveSplMultipliersTransactionQueryVariables, options?: C): Promise<CreateAddRemoveSplMultipliersTransactionQuery>;
    createSplRewardPoolTransaction(variables: CreateSplRewardPoolTransactionQueryVariables, options?: C): Promise<CreateSplRewardPoolTransactionQuery>;
    createAddRemoveRewardsFromRewardPoolTransaction(variables: CreateAddRemoveRewardsFromRewardPoolTransactionQueryVariables, options?: C): Promise<CreateAddRemoveRewardsFromRewardPoolTransactionQuery>;
    createStakeSplTokensTransaction(variables: CreateStakeSplTokensTransactionQueryVariables, options?: C): Promise<CreateStakeSplTokensTransactionQuery>;
    createClaimSplRewardsTransaction(variables: CreateClaimSplRewardsTransactionQueryVariables, options?: C): Promise<CreateClaimSplRewardsTransactionQuery>;
    createUnstakeSplTokensTransaction(variables: CreateUnstakeSplTokensTransactionQueryVariables, options?: C): Promise<CreateUnstakeSplTokensTransactionQuery>;
    createClaimStakingRewardsTransactions(variables: CreateClaimStakingRewardsTransactionsQueryVariables, options?: C): Promise<CreateClaimStakingRewardsTransactionsQuery>;
    createUnstakeCharactersTransactions(variables: CreateUnstakeCharactersTransactionsQueryVariables, options?: C): Promise<CreateUnstakeCharactersTransactionsQuery>;
    findMissions(variables?: FindMissionsQueryVariables, options?: C): Promise<FindMissionsQuery>;
    findMissionPools(variables?: FindMissionPoolsQueryVariables, options?: C): Promise<FindMissionPoolsQuery>;
    createCreateMissionPoolTransaction(variables: CreateCreateMissionPoolTransactionQueryVariables, options?: C): Promise<CreateCreateMissionPoolTransactionQuery>;
    createUpdateMissionPoolTransaction(variables: CreateUpdateMissionPoolTransactionQueryVariables, options?: C): Promise<CreateUpdateMissionPoolTransactionQuery>;
    createCreateMissionTransaction(variables: CreateCreateMissionTransactionQueryVariables, options?: C): Promise<CreateCreateMissionTransactionQuery>;
    createUpdateMissionTransaction(variables: CreateUpdateMissionTransactionQueryVariables, options?: C): Promise<CreateUpdateMissionTransactionQuery>;
    createSendCharactersOnMissionTransaction(variables: CreateSendCharactersOnMissionTransactionQueryVariables, options?: C): Promise<CreateSendCharactersOnMissionTransactionQuery>;
    createRecallCharactersTransaction(variables: CreateRecallCharactersTransactionQueryVariables, options?: C): Promise<CreateRecallCharactersTransactionQuery>;
    findResources(variables?: FindResourcesQueryVariables, options?: C): Promise<FindResourcesQuery>;
    findResourcesBalance(variables: FindResourcesBalanceQueryVariables, options?: C): Promise<FindResourcesBalanceQuery>;
    findFaucets(variables?: FindFaucetsQueryVariables, options?: C): Promise<FindFaucetsQuery>;
    findRecipes(variables?: FindRecipesQueryVariables, options?: C): Promise<FindRecipesQuery>;
    findHoldings(variables?: FindHoldingsQueryVariables, options?: C): Promise<FindHoldingsQuery>;
    createCreateNewResourceTransaction(variables: CreateCreateNewResourceTransactionQueryVariables, options?: C): Promise<CreateCreateNewResourceTransactionQuery>;
    createImportFungibleResourceTransaction(variables: CreateImportFungibleResourceTransactionQueryVariables, options?: C): Promise<CreateImportFungibleResourceTransactionQuery>;
    createExportFungibleResourceTransaction(variables: CreateExportFungibleResourceTransactionQueryVariables, options?: C): Promise<CreateExportFungibleResourceTransactionQuery>;
    createCreateNewResourceTreeTransaction(variables: CreateCreateNewResourceTreeTransactionQueryVariables, options?: C): Promise<CreateCreateNewResourceTreeTransactionQuery>;
    createMintResourceTransaction(variables: CreateMintResourceTransactionQueryVariables, options?: C): Promise<CreateMintResourceTransactionQuery>;
    createBurnResourceTransaction(variables: CreateBurnResourceTransactionQueryVariables, options?: C): Promise<CreateBurnResourceTransactionQuery>;
    createTransferResourceTransaction(variables: CreateTransferResourceTransactionQueryVariables, options?: C): Promise<CreateTransferResourceTransactionQuery>;
    createCreateWrapHoldingTransaction(variables: CreateCreateWrapHoldingTransactionQueryVariables, options?: C): Promise<CreateCreateWrapHoldingTransactionQuery>;
    createCreateUnwrapHoldingTransaction(variables: CreateCreateUnwrapHoldingTransactionQueryVariables, options?: C): Promise<CreateCreateUnwrapHoldingTransactionQuery>;
    createInitializeFaucetTransaction(variables: CreateInitializeFaucetTransactionQueryVariables, options?: C): Promise<CreateInitializeFaucetTransactionQuery>;
    createClaimFaucetTransaction(variables: CreateClaimFaucetTransactionQueryVariables, options?: C): Promise<CreateClaimFaucetTransactionQuery>;
    createInitializeRecipeTransaction(variables: CreateInitializeRecipeTransactionQueryVariables, options?: C): Promise<CreateInitializeRecipeTransactionQuery>;
    createAddIngredientsTransaction(variables: CreateAddIngredientsTransactionQueryVariables, options?: C): Promise<CreateAddIngredientsTransactionQuery>;
    createRemoveIngredientsTransaction(variables: CreateRemoveIngredientsTransactionQueryVariables, options?: C): Promise<CreateRemoveIngredientsTransactionQuery>;
    createInitCookingProcessTransactions(variables: CreateInitCookingProcessTransactionsQueryVariables, options?: C): Promise<CreateInitCookingProcessTransactionsQuery>;
    createInitializeBadgeCriteriaTransaction(variables: CreateInitializeBadgeCriteriaTransactionQueryVariables, options?: C): Promise<CreateInitializeBadgeCriteriaTransactionQuery>;
    createClaimBadgeCriteriaTransaction(variables: CreateClaimBadgeCriteriaTransactionQueryVariables, options?: C): Promise<CreateClaimBadgeCriteriaTransactionQuery>;
    createUpdateBadgeCriteriaTransaction(variables: CreateUpdateBadgeCriteriaTransactionQueryVariables, options?: C): Promise<CreateUpdateBadgeCriteriaTransactionQuery>;
};
export type Sdk = ReturnType<typeof getSdk>;
//# sourceMappingURL=generated.d.ts.map